/*!
* @nutui/nutui v3.3.8 Mon Jun 12 2023 11:24:18 GMT+0800 (中国标准时间)
* (c) 2022 @jdf2e.
* Released under the MIT License.
*/
import { f as isObject, h as getPropByPath, e as isPromise, c as createComponent } from "./component.js";
import { computed, reactive, provide, watch, resolveComponent, openBlock, createElementBlock, withModifiers, createVNode, withCtx, renderSlot } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.js";
import "../locale/lang";
const component = {
  props: {
    modelValue: {
      type: Object,
      default: {}
    },
    rules: {
      type: Object,
      default: {}
    }
  },
  components: {},
  emits: ["validate"],
  setup(props, { emit, slots }) {
    const formErrorTip = computed(() => reactive({}));
    provide("formErrorTip", formErrorTip);
    const clearErrorTips = () => {
      Object.keys(formErrorTip.value).forEach((item) => {
        formErrorTip.value[item] = "";
      });
    };
    const reset = () => {
      clearErrorTips();
    };
    watch(
      () => props.modelValue,
      () => {
        clearErrorTips();
      },
      { immediate: true }
    );
    const findFormItem = (vnodes) => {
      let task = [];
      vnodes.forEach((vnode) => {
        var _a, _b, _c, _d;
        let type = vnode.type;
        type = type.name || type;
        if (type == "nut-form-item" || (type == null ? void 0 : type.toString().endsWith("form-item"))) {
          task.push({
            prop: (_a = vnode.props) == null ? void 0 : _a["prop"],
            rules: ((_b = vnode.props) == null ? void 0 : _b["rules"]) || []
          });
        } else if (Array.isArray(vnode.children) && ((_c = vnode.children) == null ? void 0 : _c.length)) {
          task = task.concat(findFormItem(vnode.children));
        } else if (isObject(vnode.children) && Object.keys(vnode.children)) {
          if ((_d = vnode.children) == null ? void 0 : _d.default) {
            vnode.children = vnode.children.default();
            task = task.concat(findFormItem(vnode.children));
          }
        }
      });
      return task;
    };
    const tipMessage = (errorMsg) => {
      if (errorMsg.message) {
        emit("validate", errorMsg);
      }
      formErrorTip.value[errorMsg.prop] = errorMsg.message;
    };
    const checkRule = (item) => {
      const { rules, prop } = item;
      const _Promise = (errorMsg) => {
        return new Promise((resolve, reject) => {
          try {
            tipMessage(errorMsg);
            resolve(errorMsg);
          } catch (error) {
            reject(error);
          }
        });
      };
      if (!prop) {
        console.warn("[NutUI] <FormItem> \u4F7F\u7528 rules \u6821\u9A8C\u89C4\u5219\u65F6 , \u5FC5\u987B\u8BBE\u7F6E prop \u53C2\u6570");
      }
      const value = getPropByPath(props.modelValue, prop || "");
      tipMessage({ prop, message: "" });
      const formRules = props.rules || {};
      const _rules = [...(formRules == null ? void 0 : formRules[prop]) || [], ...rules];
      while (_rules.length) {
        const rule = _rules.shift();
        const { validator, ...ruleWithoutValidator } = rule;
        const { required, regex, message } = ruleWithoutValidator;
        const errorMsg = { prop, message };
        if (required) {
          if (!value && value !== 0) {
            return _Promise(errorMsg);
          }
        }
        if (regex && !regex.test(String(value))) {
          return _Promise(errorMsg);
        }
        if (validator) {
          const result = validator(value, ruleWithoutValidator);
          if (isPromise(result)) {
            return new Promise((r, j) => {
              result.then((res) => {
                if (!res) {
                  tipMessage(errorMsg);
                  r(errorMsg);
                } else {
                  r(true);
                }
              }).catch((e) => j(e));
            });
          } else {
            if (!result) {
              return _Promise(errorMsg);
            }
          }
        }
      }
      return Promise.resolve(true);
    };
    const validate = (customProp = "") => {
      return new Promise((resolve, reject) => {
        try {
          const task = findFormItem(slots.default());
          const errors = task.map((item) => {
            if (customProp) {
              if (customProp == item.prop) {
                return checkRule(item);
              } else {
                return Promise.resolve(true);
              }
            } else {
              return checkRule(item);
            }
          });
          Promise.all(errors).then((errorRes) => {
            errorRes = errorRes.filter((item) => item != true);
            const res = { valid: true, errors: [] };
            if (errorRes.length) {
              res.valid = false;
              res.errors = errorRes;
            }
            resolve(res);
          });
        } catch (error) {
          reject(error);
        }
      });
    };
    const submit = () => {
      validate();
      return false;
    };
    return { validate, reset, submit, formErrorTip };
  }
};
const { create } = createComponent("form");
const _sfc_main = create(component);
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_cell_group = resolveComponent("nut-cell-group");
  return openBlock(), createElementBlock("form", {
    class: "nut-form",
    action: "#",
    onSubmit: _cache[0] || (_cache[0] = withModifiers(() => false, ["prevent"]))
  }, [
    createVNode(_component_nut_cell_group, null, {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
    })
  ], 32);
}
var index = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { index as default };
