/*!
* @nutui/nutui v3.3.8 Mon Jun 12 2023 11:24:18 GMT+0800 (中国标准时间)
* (c) 2022 @jdf2e.
* Released under the MIT License.
*/
import { g as getScrollTopRoot, T as TypeOfFun, c as createComponent } from "./component.js";
import { ref, provide, computed, watch, onMounted, onActivated, nextTick, resolveComponent, openBlock, createElementBlock, normalizeClass, createBlock, withCtx, createElementVNode, normalizeStyle, renderSlot, Fragment, renderList, createCommentVNode, createVNode, toDisplayString } from "vue";
import { p as pxCheck } from "./pxCheck.js";
import { u as useRect } from "./index2.js";
import { r as requestAniFrame } from "./raf.js";
import { _ as _export_sfc } from "./plugin-vue_export-helper.js";
import "../locale/lang";
class Title {
  constructor() {
    this.title = "";
    this.paneKey = "";
    this.disabled = false;
  }
}
const component = {
  props: {
    modelValue: {
      type: [String, Number],
      default: 0
    },
    color: {
      type: String,
      default: ""
    },
    direction: {
      type: String,
      default: "horizontal"
    },
    size: {
      type: String,
      default: "normal"
    },
    type: {
      type: String,
      default: "line"
    },
    titleScroll: {
      type: Boolean,
      default: false
    },
    ellipsis: {
      type: Boolean,
      default: true
    },
    autoHeight: {
      type: Boolean,
      default: false
    },
    background: {
      type: String,
      default: ""
    },
    animatedTime: {
      type: [Number, String],
      default: 300
    },
    titleGutter: {
      type: [Number, String],
      default: 0
    },
    sticky: {
      type: Boolean,
      default: false
    },
    top: {
      type: Number,
      default: 0
    }
  },
  components: {},
  emits: ["update:modelValue", "click", "change"],
  setup(props, { emit, slots }) {
    const container = ref(null);
    let stickyFixed;
    provide("activeKey", { activeKey: computed(() => props.modelValue) });
    provide("autoHeight", { autoHeight: computed(() => props.autoHeight) });
    const titles = ref([]);
    const renderTitles = (vnodes) => {
      vnodes.forEach((vnode, index2) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i;
        let type = vnode.type;
        type = type.name || type;
        if (type == "nut-tabpane") {
          let title = new Title();
          if (((_a = vnode.props) == null ? void 0 : _a.title) || ((_b = vnode.props) == null ? void 0 : _b["pane-key"]) || ((_c = vnode.props) == null ? void 0 : _c["paneKey"])) {
            let paneKeyType = TypeOfFun((_d = vnode.props) == null ? void 0 : _d["pane-key"]);
            let paneIndex = paneKeyType == "number" || paneKeyType == "string" ? String((_e = vnode.props) == null ? void 0 : _e["pane-key"]) : null;
            let camelPaneKeyType = TypeOfFun((_f = vnode.props) == null ? void 0 : _f["paneKey"]);
            let camelPaneIndex = camelPaneKeyType == "number" || camelPaneKeyType == "string" ? String((_g = vnode.props) == null ? void 0 : _g["paneKey"]) : null;
            title.title = (_h = vnode.props) == null ? void 0 : _h.title;
            title.paneKey = paneIndex || camelPaneIndex || String(index2);
            title.disabled = (_i = vnode.props) == null ? void 0 : _i.disabled;
          }
          titles.value.push(title);
        } else {
          if (vnode.children == " ") {
            return;
          }
          renderTitles(vnode.children);
        }
      });
    };
    const currentIndex = ref(props.modelValue || 0);
    const findTabsIndex = (value) => {
      let index2 = titles.value.findIndex((item) => item.paneKey == value);
      if (titles.value.length == 0) {
        console.error("[NutUI] <Tabs> \u5F53\u524D\u672A\u627E\u5230 TabPane \u7EC4\u4EF6\u5143\u7D20 , \u8BF7\u68C0\u67E5 .");
      } else if (index2 == -1) {
        console.error("[NutUI] <Tabs> \u8BF7\u68C0\u67E5 v-model \u503C\u662F\u5426\u4E3A paneKey ,\u5982 paneKey \u672A\u8BBE\u7F6E\uFF0C\u8BF7\u91C7\u7528\u4E0B\u6807\u63A7\u5236 .");
      } else {
        currentIndex.value = index2;
      }
    };
    const getScrollY = computed(() => {
      if (props.titleScroll && props.direction === "vertical") {
        return true;
      }
      return false;
    });
    const navRef = ref();
    const titleRef = ref([]);
    const scrollIntoView = (immediate) => {
      const nav = navRef.value;
      const _titles = titleRef.value;
      if (!nav || !_titles || !_titles[currentIndex.value]) {
        return;
      }
      const title = _titles[currentIndex.value];
      let to = 0;
      if (props.direction === "vertical") {
        const runTop = title.offsetTop - nav.offsetTop + 10;
        to = runTop - (nav.offsetHeight - title.offsetHeight) / 2;
      } else {
        to = title.offsetLeft - (nav.offsetWidth - title.offsetWidth) / 2;
      }
      scrollDirection(nav, to, immediate ? 0 : 0.3, props.direction);
    };
    const scrollDirection = (nav, to, duration, direction) => {
      let count = 0;
      const from = direction === "horizontal" ? nav.scrollLeft : nav.scrollTop;
      const frames = duration === 0 ? 1 : Math.round(duration * 1e3 / 16);
      function animate() {
        if (direction === "horizontal") {
          nav.scrollLeft += (to - from) / frames;
        } else {
          nav.scrollTop += (to - from) / frames;
        }
        if (++count < frames) {
          requestAniFrame(animate);
        }
      }
      animate();
    };
    const init = (vnodes = ((_a) => (_a = slots.default) == null ? void 0 : _a.call(slots))()) => {
      titles.value = [];
      vnodes = vnodes == null ? void 0 : vnodes.filter((item) => typeof item.children !== "string");
      if (vnodes && vnodes.length) {
        renderTitles(vnodes);
      }
      findTabsIndex(props.modelValue);
      nextTick(() => {
        scrollIntoView();
      });
    };
    const onStickyScroll = (params) => {
      stickyFixed = params.fixed;
    };
    watch(
      () => {
        var _a;
        return (_a = slots.default) == null ? void 0 : _a.call(slots);
      },
      (vnodes) => {
        init(vnodes);
      }
    );
    watch(
      () => props.modelValue,
      (value) => {
        findTabsIndex(value);
        scrollIntoView();
        if (stickyFixed) {
          let top = useRect(container.value).top + getScrollTopRoot();
          let value2 = Math.ceil(top - props.top);
          window.scrollTo({
            top: value2,
            behavior: "smooth"
          });
        }
      }
    );
    onMounted(init);
    onActivated(init);
    const contentStyle = computed(() => {
      return {
        transform: props.direction == "horizontal" ? `translate3d(-${currentIndex.value * 100}%, 0, 0)` : `translate3d( 0,-${currentIndex.value * 100}%, 0)`,
        transitionDuration: `${props.animatedTime}ms`
      };
    });
    const tabsNavStyle = computed(() => {
      return {
        background: props.background
      };
    });
    const tabsActiveStyle = computed(() => {
      return {
        color: props.type == "smile" ? props.color : "",
        background: props.type == "line" ? props.color : ""
      };
    });
    const titleStyle = computed(() => {
      return {
        marginLeft: pxCheck(props.titleGutter),
        marginRight: pxCheck(props.titleGutter)
      };
    });
    const methods = {
      tabChange: (item, index2) => {
        emit("click", item);
        if (item.disabled || currentIndex.value == index2) {
          return;
        }
        currentIndex.value = index2;
        emit("update:modelValue", item.paneKey);
        emit("change", item);
      },
      setTabItemRef: (el, index2) => {
        titleRef.value[index2] = el;
      }
    };
    return {
      navRef,
      titles,
      contentStyle,
      tabsNavStyle,
      titleStyle,
      tabsActiveStyle,
      container,
      getScrollY,
      onStickyScroll,
      ...methods
    };
  }
};
const { create } = createComponent("tabs");
const _sfc_main = create(component);
const _hoisted_1 = ["onClick"];
const _hoisted_2 = ["onClick"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  const _component_nut_sticky = resolveComponent("nut-sticky");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(["nut-tabs", [_ctx.direction]]),
    ref: "container",
    id: "container"
  }, [
    _ctx.sticky ? (openBlock(), createBlock(_component_nut_sticky, {
      key: 0,
      top: _ctx.top,
      container: _ctx.container,
      onScroll: _ctx.onStickyScroll
    }, {
      default: withCtx(() => [
        createElementVNode("view", {
          class: normalizeClass(["nut-tabs__titles", { [_ctx.type]: _ctx.type, scrollable: _ctx.titleScroll, [_ctx.size]: _ctx.size }]),
          style: normalizeStyle(_ctx.tabsNavStyle),
          ref: "navRef"
        }, [
          _ctx.$slots.titles ? renderSlot(_ctx.$slots, "titles", { key: 0 }) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.titles, (item, index2) => {
            return openBlock(), createElementBlock("view", {
              class: normalizeClass(["nut-tabs__titles-item", { active: item.paneKey == _ctx.modelValue, disabled: item.disabled }]),
              style: normalizeStyle(_ctx.titleStyle),
              onClick: ($event) => _ctx.tabChange(item, index2),
              key: item.paneKey
            }, [
              _ctx.type == "line" ? (openBlock(), createElementBlock("view", {
                key: 0,
                class: "nut-tabs__titles-item__line",
                style: normalizeStyle(_ctx.tabsActiveStyle)
              }, null, 4)) : createCommentVNode("", true),
              _ctx.type == "smile" ? (openBlock(), createElementBlock("view", {
                key: 1,
                class: "nut-tabs__titles-item__smile",
                style: normalizeStyle(_ctx.tabsActiveStyle)
              }, [
                createVNode(_component_nut_icon, {
                  color: _ctx.color,
                  name: "joy-smile"
                }, null, 8, ["color"])
              ], 4)) : createCommentVNode("", true),
              createElementVNode("view", {
                class: normalizeClass(["nut-tabs__titles-item__text", { ellipsis: _ctx.ellipsis }])
              }, toDisplayString(item.title), 3)
            ], 14, _hoisted_1);
          }), 128))
        ], 6)
      ]),
      _: 3
    }, 8, ["top", "container", "onScroll"])) : (openBlock(), createElementBlock("view", {
      key: 1,
      class: normalizeClass(["nut-tabs__titles", { [_ctx.type]: _ctx.type, scrollable: _ctx.titleScroll, "scroll-vertical": _ctx.getScrollY, [_ctx.size]: _ctx.size }]),
      style: normalizeStyle(_ctx.tabsNavStyle),
      ref: "navRef"
    }, [
      _ctx.$slots.titles ? renderSlot(_ctx.$slots, "titles", { key: 0 }) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.titles, (item, index2) => {
        return openBlock(), createElementBlock("view", {
          class: normalizeClass(["nut-tabs__titles-item", { active: item.paneKey == _ctx.modelValue, disabled: item.disabled }]),
          style: normalizeStyle(_ctx.titleStyle),
          onClick: ($event) => _ctx.tabChange(item, index2),
          key: item.paneKey,
          ref: (e) => _ctx.setTabItemRef(e, index2)
        }, [
          _ctx.type == "line" ? (openBlock(), createElementBlock("view", {
            key: 0,
            class: "nut-tabs__titles-item__line",
            style: normalizeStyle(_ctx.tabsActiveStyle)
          }, null, 4)) : createCommentVNode("", true),
          _ctx.type == "smile" ? (openBlock(), createElementBlock("view", {
            key: 1,
            class: "nut-tabs__titles-item__smile",
            style: normalizeStyle(_ctx.tabsActiveStyle)
          }, [
            createVNode(_component_nut_icon, {
              color: _ctx.color,
              name: "joy-smile"
            }, null, 8, ["color"])
          ], 4)) : createCommentVNode("", true),
          createElementVNode("view", {
            class: normalizeClass(["nut-tabs__titles-item__text", { ellipsis: _ctx.ellipsis }])
          }, toDisplayString(item.title), 3)
        ], 14, _hoisted_2);
      }), 128))
    ], 6)),
    createElementVNode("view", {
      class: "nut-tabs__content",
      style: normalizeStyle(_ctx.contentStyle)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 4)
  ], 2);
}
var index = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { index as default };
