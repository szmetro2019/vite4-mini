/*!
* @nutui/nutui v3.3.8 Mon Jun 12 2023 11:24:18 GMT+0800 (中国标准时间)
* (c) 2022 @jdf2e.
* Released under the MIT License.
*/
import { c as createComponent } from "./component.js";
import { reactive, computed, watch, watchEffect, toRefs, resolveComponent, openBlock, createBlock, Teleport, mergeProps, createCommentVNode, createVNode, Transition, withCtx, withDirectives, createElementVNode, normalizeClass, normalizeStyle, renderSlot, createElementBlock, vShow } from "vue";
import { p as popupProps } from "./props.js";
import { _ as _export_sfc } from "./plugin-vue_export-helper.js";
import "../locale/lang";
const initIndex = 2e3;
let _zIndex = initIndex;
const component = (componentName2) => {
  return {
    components: {},
    props: {
      ...popupProps
    },
    emits: ["click-pop", "click-close-icon", "open", "close", "opend", "closed", "click-overlay", "update:visible"],
    setup(props, { emit }) {
      const state = reactive({
        zIndex: props.zIndex,
        showSlot: true,
        closed: props.closeable
      });
      const classes = computed(() => {
        const prefixCls = componentName2;
        return {
          [prefixCls]: true,
          ["round"]: props.round,
          [`popup-${props.position}`]: true,
          [`popup-${props.position}--safebottom`]: props.position === "bottom" && props.safeAreaInsetBottom,
          [props.popClass]: true
        };
      });
      const popStyle = computed(() => {
        return {
          zIndex: state.zIndex,
          transitionDuration: `${props.duration}s`,
          ...props.style
        };
      });
      const transitionName = computed(() => {
        return props.transition ? props.transition : `popup-slide-${props.position}`;
      });
      const open = () => {
        if (props.zIndex !== initIndex) {
          _zIndex = Number(props.zIndex);
        }
        emit("update:visible", true);
        state.zIndex = ++_zIndex;
        if (props.destroyOnClose) {
          state.showSlot = true;
        }
        emit("open");
      };
      const close = () => {
        emit("update:visible", false);
        emit("close");
        if (props.destroyOnClose) {
          setTimeout(() => {
            state.showSlot = false;
          }, +props.duration * 1e3);
        }
      };
      const onClick = (e) => {
        emit("click-pop", e);
      };
      const onClickCloseIcon = (e) => {
        e.stopPropagation();
        emit("click-close-icon", e);
        emit("update:visible", false);
      };
      const onClickOverlay = (e) => {
        emit("click-overlay", e);
        if (props.closeOnClickOverlay) {
          emit("update:visible", false);
        }
      };
      const onOpened = (e) => {
        emit("opend", e);
      };
      const onClosed = (e) => {
        emit("closed", e);
      };
      watch(
        () => props.visible,
        (val) => {
          props.visible ? open() : close();
        }
      );
      watchEffect(() => {
        state.closed = props.closeable;
      });
      return {
        ...toRefs(state),
        popStyle,
        transitionName,
        classes,
        onClick,
        onClickCloseIcon,
        onClickOverlay,
        onOpened,
        onClosed
      };
    }
  };
};
const { componentName, create } = createComponent("popup");
const _sfc_main = create(component(componentName));
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_overlay = resolveComponent("nut-overlay");
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createBlock(Teleport, {
    to: _ctx.teleport,
    disabled: !_ctx.teleportDisable
  }, [
    _ctx.overlay ? (openBlock(), createBlock(_component_nut_overlay, mergeProps({
      key: 0,
      visible: _ctx.visible,
      "close-on-click-overlay": _ctx.closeOnClickOverlay,
      "z-index": _ctx.zIndex,
      "lock-scroll": _ctx.lockScroll,
      duration: _ctx.duration,
      "overlay-class": _ctx.overlayClass,
      "overlay-style": _ctx.overlayStyle,
      onClick: _ctx.onClickOverlay
    }, _ctx.$attrs), null, 16, ["visible", "close-on-click-overlay", "z-index", "lock-scroll", "duration", "overlay-class", "overlay-style", "onClick"])) : createCommentVNode("", true),
    createVNode(Transition, {
      name: _ctx.transitionName,
      onAfterEnter: _ctx.onOpened,
      onAfterLeave: _ctx.onClosed
    }, {
      default: withCtx(() => [
        withDirectives(createElementVNode("view", {
          class: normalizeClass(_ctx.classes),
          style: normalizeStyle(_ctx.popStyle),
          onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onClick && _ctx.onClick(...args))
        }, [
          _ctx.showSlot ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true),
          _ctx.closed ? (openBlock(), createElementBlock("view", {
            key: 1,
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickCloseIcon && _ctx.onClickCloseIcon(...args)),
            class: normalizeClass(["nut-popup__close-icon", "nut-popup__close-icon--" + _ctx.closeIconPosition])
          }, [
            createVNode(_component_nut_icon, mergeProps(_ctx.$attrs, {
              name: _ctx.closeIcon,
              size: "12px"
            }), null, 16, ["name"])
          ], 2)) : createCommentVNode("", true)
        ], 6), [
          [vShow, _ctx.visible]
        ])
      ]),
      _: 3
    }, 8, ["name", "onAfterEnter", "onAfterLeave"])
  ], 8, ["to", "disabled"]);
}
var Popup = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Popup as default };
