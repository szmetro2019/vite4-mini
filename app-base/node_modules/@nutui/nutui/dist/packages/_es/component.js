/*!
* @nutui/nutui v3.3.8 Mon Jun 12 2023 11:24:18 GMT+0800 (中国标准时间)
* (c) 2022 @jdf2e.
* Released under the MIT License.
*/
import { defineComponent } from "vue";
import locale from "../locale/lang";
const TypeOfFun = (value) => {
  if (null === value) {
    return "null";
  }
  const type = typeof value;
  if ("undefined" === type || "string" === type) {
    return type;
  }
  const typeString = toString.call(value);
  switch (typeString) {
    case "[object Array]":
      return "array";
    case "[object Date]":
      return "date";
    case "[object Boolean]":
      return "boolean";
    case "[object Number]":
      return "number";
    case "[object Function]":
      return "function";
    case "[object RegExp]":
      return "regexp";
    case "[object Object]":
      if (void 0 !== value.nodeType) {
        if (3 == value.nodeType) {
          return /\S/.test(value.nodeValue) ? "textnode" : "whitespace";
        } else {
          return "element";
        }
      } else {
        return "object";
      }
    default:
      return "unknow";
  }
};
const isArray = Array.isArray;
const isDate = (val) => val instanceof Date;
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const docu = document;
const body = docu.body;
const getPropByPath = (obj, keyPath) => {
  try {
    return keyPath.split(".").reduce((prev, curr) => prev[curr], obj);
  } catch (error) {
    return "";
  }
};
const floatData = (format, dataOp, mapOps) => {
  let mergeFormat = Object.assign({}, format);
  let mergeMapOps = Object.assign({}, mapOps);
  if (Object.keys(dataOp).length > 0) {
    Object.keys(mergeFormat).forEach((keys) => {
      if (mergeMapOps.hasOwnProperty(keys)) {
        const tof = TypeOfFun(mergeMapOps[keys]);
        if (tof == "function") {
          mergeFormat[keys] = mergeMapOps[keys](dataOp);
        }
        if (tof == "string") {
          mergeFormat[keys] = dataOp[mergeMapOps[keys]];
        }
      } else {
        if (dataOp[keys])
          mergeFormat[keys] = dataOp[keys];
      }
    });
    return mergeFormat;
  }
  return format;
};
function myFixed(num, digit = 2) {
  if (Object.is(parseFloat(num), NaN)) {
    return console.log(`\u4F20\u5165\u7684\u503C\uFF1A${num}\u4E0D\u662F\u4E00\u4E2A\u6570\u5B57`);
  }
  num = parseFloat(num);
  return (Math.round((num + Number.EPSILON) * Math.pow(10, digit)) / Math.pow(10, digit)).toFixed(digit);
}
function preventDefault(event, isStopPropagation) {
  if (typeof event.cancelable !== "boolean" || event.cancelable) {
    event.preventDefault();
  }
  if (isStopPropagation) {
    event.stopPropagation();
  }
}
const padZero = (num, length = 2) => {
  num += "";
  while (num.length < length) {
    num = "0" + num;
  }
  return num.toString();
};
const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
const getScrollTopRoot = () => {
  return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
};
function createComponent(name) {
  const componentName = "nut-" + name;
  return {
    componentName,
    translate(keyPath, ...args) {
      const languages = locale.languages();
      const text = getPropByPath(languages, `${name.replace("-", "")}.${keyPath}`) || getPropByPath(languages, keyPath);
      return isFunction(text) ? text(...args) : text;
    },
    create: function(_component) {
      _component.baseName = name;
      _component.name = componentName;
      _component.install = (vue) => {
        vue.component(_component.name, _component);
      };
      return defineComponent(_component);
    },
    createDemo: function(_component) {
      _component.baseName = name;
      _component.name = "demo-" + name;
      return defineComponent(_component);
    }
  };
}
export { TypeOfFun as T, preventDefault as a, body as b, createComponent as c, clamp as d, isPromise as e, isObject as f, getScrollTopRoot as g, getPropByPath as h, isDate as i, isString as j, isFunction as k, isArray as l, myFixed as m, floatData as n, padZero as p };
