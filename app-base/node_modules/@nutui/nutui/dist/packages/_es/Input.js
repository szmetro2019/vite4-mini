/*!
* @nutui/nutui v3.3.8 Mon Jun 12 2023 11:24:18 GMT+0800 (中国标准时间)
* (c) 2022 @jdf2e.
* Released under the MIT License.
*/
import { ref, reactive, computed, watch, onMounted, h, resolveComponent, openBlock, createElementBlock, normalizeClass, createVNode, mergeProps, createCommentVNode, normalizeStyle, createElementVNode, toDisplayString, renderSlot, createBlock, resolveDynamicComponent, withDirectives, vShow, createTextVNode } from "vue";
import { c as createComponent } from "./component.js";
import { _ as _export_sfc } from "./plugin-vue_export-helper.js";
import "../locale/lang";
function trimExtraChar(value, char, regExp) {
  const index2 = value.indexOf(char);
  if (index2 === -1) {
    return value;
  }
  if (char === "-" && index2 !== 0) {
    return value.slice(0, index2);
  }
  return value.slice(0, index2 + 1) + value.slice(index2).replace(regExp, "");
}
function formatNumber(value, allowDot = true, allowMinus = true) {
  if (allowDot) {
    value = trimExtraChar(value, ".", /\./g);
  } else {
    value = value.split(".")[0];
  }
  if (allowMinus) {
    value = trimExtraChar(value, "-", /-/g);
  } else {
    value = value.replace(/-/, "");
  }
  const regExp = allowDot ? /[^-0-9.]/g : /[^-0-9]/g;
  return value.replace(regExp, "");
}
const { componentName, create } = createComponent("input");
const _sfc_main = create({
  props: {
    ref: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      default: "text"
    },
    modelValue: {
      type: String,
      default: ""
    },
    placeholder: {
      type: String,
      default: ""
    },
    label: {
      type: String,
      default: ""
    },
    labelClass: {
      type: String,
      default: ""
    },
    labelWidth: {
      type: [String, Number],
      default: "80"
    },
    labelAlign: {
      type: String,
      default: "left"
    },
    colon: {
      type: Boolean,
      default: false
    },
    inputAlign: {
      type: String,
      default: "left"
    },
    center: {
      type: Boolean,
      default: false
    },
    required: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    error: {
      type: Boolean,
      default: false
    },
    maxLength: {
      type: [String, Number],
      default: "9999"
    },
    leftIcon: {
      type: String,
      default: ""
    },
    leftIconSize: {
      type: [String, Number],
      default: ""
    },
    rightIcon: {
      type: String,
      default: ""
    },
    rightIconSize: {
      type: [String, Number],
      default: ""
    },
    clearable: {
      type: Boolean,
      default: false
    },
    clearIcon: {
      type: String,
      default: "mask-close"
    },
    clearSize: {
      type: [String, Number],
      default: "14"
    },
    border: {
      type: Boolean,
      default: true
    },
    formatTrigger: {
      type: String,
      default: "onChange"
    },
    formatter: {
      type: Function,
      default: null
    },
    rules: {
      type: Array,
      default: []
    },
    errorMessage: {
      type: String,
      default: ""
    },
    errorMessageAlign: {
      type: String,
      default: ""
    },
    rows: {
      type: [String, Number],
      default: null
    },
    showWordLimit: {
      type: Boolean,
      default: false
    },
    autofocus: {
      type: Boolean,
      default: false
    },
    confirmType: {
      type: String,
      default: "done"
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "blur",
    "focus",
    "clear",
    "keypress",
    "click-input",
    "click-left-icon",
    "click-right-icon"
  ],
  setup(props, { emit, slots }) {
    const active = ref(false);
    const inputRef = ref();
    const getModelValue = () => {
      var _a;
      return String((_a = props.modelValue) != null ? _a : "");
    };
    const renderInput = (type) => {
      return h(type == "textarea" ? "textarea" : "input", {
        style: type == "textarea" ? stylesTextarea : styles,
        type: type != "textarea" && inputType(type)
      });
    };
    const state = reactive({
      focused: false,
      validateFailed: false,
      validateMessage: ""
    });
    const classes = computed(() => {
      const prefixCls = componentName;
      return {
        [prefixCls]: true,
        center: props.center,
        [`${prefixCls}-readonly`]: props.readonly,
        [`${prefixCls}-disabled`]: props.disabled,
        [`${prefixCls}-required`]: props.required,
        [`${prefixCls}-error`]: props.error,
        [`${prefixCls}-border`]: props.border
      };
    });
    const styles = computed(() => {
      return {
        textAlign: props.inputAlign
      };
    });
    const stylesTextarea = computed(() => {
      return {
        textAlign: props.inputAlign,
        height: Number(props.rows) * 24 + "px"
      };
    });
    const inputType = (type) => {
      if (type === "number") {
        return "text";
      } else if (type === "digit") {
        return "tel";
      } else {
        return type;
      }
    };
    const onInput = (event) => {
      const input = event.target;
      let value = input.value;
      if (props.maxLength && value.length > Number(props.maxLength)) {
        value = value.slice(0, Number(props.maxLength));
      }
      updateValue(value);
    };
    const updateValue = (value, trigger = "onChange") => {
      var _a;
      if (props.type === "digit") {
        value = formatNumber(value, false, false);
      }
      if (props.type === "number") {
        value = formatNumber(value, true, true);
      }
      if (props.formatter && trigger === props.formatTrigger) {
        value = props.formatter(value);
      }
      if (((_a = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _a.value) !== value) {
        inputRef.value.value = value;
      }
      if (value !== props.modelValue) {
        emit("update:modelValue", value);
        emit("change", value);
      }
    };
    const onFocus = (event) => {
      if (props.disabled || props.readonly) {
        return;
      }
      const input = event.target;
      let value = input.value;
      active.value = true;
      emit("focus", event);
      emit("update:modelValue", value);
    };
    const onBlur = (event) => {
      if (props.disabled || props.readonly) {
        return;
      }
      setTimeout(() => {
        active.value = false;
      }, 200);
      const input = event.target;
      let value = input.value;
      if (props.maxLength && value.length > Number(props.maxLength)) {
        value = value.slice(0, Number(props.maxLength));
      }
      updateValue(getModelValue(), "onBlur");
      emit("blur", event);
      emit("update:modelValue", value);
    };
    const clear = (event) => {
      event.stopPropagation();
      if (props.disabled)
        return;
      emit("clear", "", event);
    };
    const resetValidation = () => {
      if (state.validateFailed) {
        state.validateFailed = false;
        state.validateMessage = "";
      }
    };
    const onClickInput = (event) => {
      if (props.disabled) {
        return;
      }
      emit("click-input", event);
    };
    const onClickLeftIcon = (event) => {
      event.stopPropagation();
      if (props.disabled) {
        return;
      }
      emit("click-left-icon", event);
    };
    const onClickRightIcon = (event) => {
      event.stopPropagation();
      if (props.disabled) {
        return;
      }
      emit("click-right-icon", event);
    };
    watch(
      () => props.modelValue,
      () => {
        if (!slots.input) {
          updateValue(getModelValue());
          resetValidation();
        }
      }
    );
    onMounted(() => {
      if (!slots.input) {
        updateValue(getModelValue(), props.formatTrigger);
      }
    });
    return {
      renderInput,
      inputRef,
      active,
      classes,
      styles,
      stylesTextarea,
      inputType,
      onInput,
      onFocus,
      onBlur,
      clear,
      onClickInput,
      onClickLeftIcon,
      onClickRightIcon
    };
  }
});
const _hoisted_1 = { class: "label-string" };
const _hoisted_2 = {
  key: 2,
  class: "nut-input-value"
};
const _hoisted_3 = {
  key: 3,
  class: "nut-input-value"
};
const _hoisted_4 = { class: "nut-input-inner" };
const _hoisted_5 = { class: "nut-input-box" };
const _hoisted_6 = { class: "nut-input-clear-box" };
const _hoisted_7 = {
  key: 0,
  class: "nut-input-word-limit"
};
const _hoisted_8 = { class: "nut-input-word-num" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    _ctx.leftIcon && _ctx.leftIcon.length > 0 ? (openBlock(), createElementBlock("view", {
      key: 0,
      class: "nut-input-left-icon",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickLeftIcon && _ctx.onClickLeftIcon(...args))
    }, [
      createVNode(_component_nut_icon, mergeProps({ name: _ctx.leftIcon }, _ctx.$attrs, { size: _ctx.leftIconSize }), null, 16, ["name", "size"])
    ])) : createCommentVNode("", true),
    _ctx.label ? (openBlock(), createElementBlock("view", {
      key: 1,
      class: normalizeClass(["nut-input-label", _ctx.labelClass]),
      style: normalizeStyle({
        width: `${_ctx.labelWidth}px`,
        textAlign: _ctx.labelAlign
      })
    }, [
      createElementVNode("view", _hoisted_1, toDisplayString(_ctx.label) + " " + toDisplayString(_ctx.colon ? ":" : ""), 1)
    ], 6)) : createCommentVNode("", true),
    _ctx.$slots.input ? (openBlock(), createElementBlock("view", _hoisted_2, [
      createElementVNode("view", {
        class: "nut-input-inner",
        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onClickInput && _ctx.onClickInput(...args))
      }, [
        renderSlot(_ctx.$slots, "input")
      ])
    ])) : (openBlock(), createElementBlock("view", _hoisted_3, [
      createElementVNode("view", _hoisted_4, [
        createElementVNode("view", _hoisted_5, [
          (openBlock(), createBlock(resolveDynamicComponent(_ctx.renderInput(_ctx.type)), {
            class: "input-text",
            ref: "inputRef",
            style: normalizeStyle(_ctx.styles),
            maxlength: _ctx.maxLength,
            placeholder: _ctx.placeholder,
            disabled: _ctx.disabled,
            readonly: _ctx.readonly,
            value: _ctx.modelValue,
            formatTrigger: _ctx.formatTrigger,
            autofocus: _ctx.autofocus,
            enterkeyhint: _ctx.confirmType,
            onInput: _ctx.onInput,
            onFocus: _ctx.onFocus,
            onBlur: _ctx.onBlur,
            onClick: _ctx.onClickInput
          }, null, 8, ["style", "maxlength", "placeholder", "disabled", "readonly", "value", "formatTrigger", "autofocus", "enterkeyhint", "onInput", "onFocus", "onBlur", "onClick"]))
        ]),
        createElementVNode("view", _hoisted_6, [
          _ctx.clearable && !_ctx.readonly ? withDirectives((openBlock(), createBlock(_component_nut_icon, mergeProps({
            key: 0,
            class: "nut-input-clear",
            name: _ctx.clearIcon
          }, _ctx.$attrs, {
            size: _ctx.clearSize,
            onClick: _ctx.clear
          }), null, 16, ["name", "size", "onClick"])), [
            [vShow, _ctx.active && _ctx.modelValue.length > 0]
          ]) : createCommentVNode("", true)
        ]),
        _ctx.rightIcon && _ctx.rightIcon.length > 0 ? (openBlock(), createElementBlock("view", {
          key: 0,
          class: "nut-input-right-icon",
          onClick: _cache[2] || (_cache[2] = (...args) => _ctx.onClickRightIcon && _ctx.onClickRightIcon(...args))
        }, [
          createVNode(_component_nut_icon, mergeProps({ name: _ctx.rightIcon }, _ctx.$attrs, { size: _ctx.rightIconSize }), null, 16, ["name", "size"])
        ])) : createCommentVNode("", true),
        _ctx.$slots.button ? renderSlot(_ctx.$slots, "button", {
          key: 1,
          class: "nut-input-button"
        }) : createCommentVNode("", true),
        _ctx.$slots.rightExtra ? renderSlot(_ctx.$slots, "rightExtra", { key: 2 }) : createCommentVNode("", true)
      ]),
      _ctx.showWordLimit && _ctx.maxLength ? (openBlock(), createElementBlock("view", _hoisted_7, [
        createElementVNode("span", _hoisted_8, toDisplayString(_ctx.modelValue ? _ctx.modelValue.length : 0), 1),
        createTextVNode("/" + toDisplayString(_ctx.maxLength), 1)
      ])) : createCommentVNode("", true),
      _ctx.errorMessage ? (openBlock(), createElementBlock("view", {
        key: 1,
        class: "nut-input-error-message",
        style: normalizeStyle({
          textAlign: _ctx.errorMessageAlign
        })
      }, toDisplayString(_ctx.errorMessage), 5)) : createCommentVNode("", true)
    ]))
  ], 2);
}
var index = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { index as default };
