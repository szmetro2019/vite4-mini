/*!
* @nutui/nutui v3.3.8 Mon Jun 12 2023 11:24:18 GMT+0800 (中国标准时间)
* (c) 2022 @jdf2e.
* Released under the MIT License.
*/
import { c as createComponent } from "./component.js";
import { inject, reactive, computed, watch, onMounted, getCurrentInstance, onBeforeUnmount, h } from "vue";
import _sfc_main$1 from "./Icon.js";
import "../locale/lang";
import "./pxCheck.js";
const component = (componentName2, nutIcon) => {
  return {
    components: {
      nutIcon
    },
    props: {
      modelValue: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      textPosition: {
        type: String,
        default: "right"
      },
      iconSize: {
        type: [String, Number],
        default: ""
      },
      iconName: {
        type: String,
        default: "check-normal"
      },
      iconActiveName: {
        type: String,
        default: "checked"
      },
      iconIndeterminateName: {
        type: String,
        default: "check-disabled"
      },
      label: {
        type: String,
        default: ""
      },
      iconClassPrefix: {
        type: String,
        default: "nut-icon"
      },
      iconFontClassName: {
        type: String,
        default: "nutui-iconfont"
      },
      indeterminate: {
        type: Boolean,
        default: false
      },
      shape: {
        type: String,
        default: "round"
      }
    },
    emits: ["change", "update:modelValue"],
    setup(props, { emit, slots }) {
      const parent = inject("parent", null);
      const state = reactive({
        partialSelect: props.indeterminate
      });
      const hasParent = computed(() => !!parent);
      const pValue = computed(() => {
        if (hasParent.value) {
          return parent.value.value.includes(props.label);
        } else {
          return props.modelValue;
        }
      });
      const pDisabled = computed(() => {
        return hasParent.value ? parent.disabled.value ? parent.disabled.value : props.disabled : props.disabled;
      });
      const checked = computed(() => !!props.modelValue);
      const color = computed(() => {
        return !pDisabled.value ? !pValue.value ? "nut-checkbox__icon--unchecked" : state.partialSelect ? "nut-checkbox__icon--indeterminate" : "nut-checkbox__icon" : "nut-checkbox__icon--disable";
      });
      let updateType = "";
      const emitChange = (value, label) => {
        updateType = "click";
        emit("update:modelValue", value);
        emit("change", value, label);
      };
      watch(
        () => props.modelValue,
        (v) => {
          if (updateType == "click") {
            updateType = "";
          } else {
            emit("change", v);
          }
        }
      );
      const renderIcon = () => {
        const { iconName, iconSize, iconActiveName, iconClassPrefix, iconFontClassName, iconIndeterminateName } = props;
        return h(nutIcon, {
          name: !pValue.value ? iconName : state.partialSelect ? iconIndeterminateName : iconActiveName,
          size: iconSize,
          class: color.value,
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName
        });
      };
      const renderLabel = () => {
        var _a;
        return h(
          "view",
          {
            class: `${componentName2}__label ${pDisabled.value ? `${componentName2}__label--disabled` : ""}`
          },
          (_a = slots.default) == null ? void 0 : _a.call(slots)
        );
      };
      const renderButton = () => {
        var _a;
        return h(
          "view",
          {
            class: `${componentName2}__button ${pValue.value && `${componentName2}__button--active`} ${pDisabled.value ? `${componentName2}__button--disabled` : ""}`
          },
          (_a = slots.default) == null ? void 0 : _a.call(slots)
        );
      };
      const handleClick = (e) => {
        var _a, _b;
        if (pDisabled.value)
          return;
        if (checked.value && state.partialSelect) {
          state.partialSelect = false;
          emitChange(checked.value, (_a = slots.default) == null ? void 0 : _a.call(slots)[0].children);
          return;
        }
        emitChange(!checked.value, (_b = slots.default) == null ? void 0 : _b.call(slots)[0].children);
        if (hasParent.value) {
          const value = parent.value.value;
          const max = parent.max.value;
          const { label } = props;
          const index = value.indexOf(label);
          if (index > -1) {
            value.splice(index, 1);
          } else if (index <= -1 && (value.length < max || !max)) {
            value.push(label);
          }
          parent.updateValue(value);
        }
      };
      onMounted(() => {
        hasParent.value && parent["relation"](getCurrentInstance());
      });
      onBeforeUnmount(() => {
        hasParent.value && parent["relation"](getCurrentInstance(), true);
      });
      watch(
        () => props.indeterminate,
        (newVal) => {
          state.partialSelect = newVal;
        }
      );
      return () => {
        return h(
          "view",
          {
            class: `${componentName2} ${componentName2}--${props.shape} ${props.textPosition === "left" ? `${componentName2}--reverse` : ""}`,
            onClick: handleClick
          },
          [props.shape == "button" ? renderButton() : [renderIcon(), renderLabel()]]
        );
      };
    }
  };
};
const { create, componentName } = createComponent("checkbox");
const _sfc_main = create(component(componentName, _sfc_main$1));
export { _sfc_main as default };
