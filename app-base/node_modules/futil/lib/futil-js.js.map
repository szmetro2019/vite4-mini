{"version":3,"sources":["webpack://futil-js/webpack/universalModuleDefinition","webpack://futil-js/webpack/bootstrap","webpack://futil-js/external \"lodash/fp\"","webpack://futil-js/./src/array.js","webpack://futil-js/./src/conversion.js","webpack://futil-js/./src/collection.js","webpack://futil-js/./src/lang.js","webpack://futil-js/./src/logic.js","webpack://futil-js/./src/function.js","webpack://futil-js/./src/tree.js","webpack://futil-js/./src/aspect.js","webpack://futil-js/./src/iterators.js","webpack://futil-js/./src/lens.js","webpack://futil-js/./src/regex.js","webpack://futil-js/./src/object.js","webpack://futil-js/./src/string.js","webpack://futil-js/./src/async.js","webpack://futil-js/./src/index.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_function","_collection","_conversion","callUnlessEmptyArray","check","failFn","fn","x","y","callUnless","_","isEmpty","callUnlessEmpty","dropRight","last","takeRight","compactJoin","curry","join","compact","push","dotJoin","dotJoinWith","flow","filter","repeated","groupBy","e","length","flatten","uniq","val","arr","concat","actuallMergeRanges","pushIn","pushOn","moveIndex","from","to","pullAt","insertAtIndex","overlaps","max","mergeRange","arrayToObject","mergeRanges","sortBy","reduce","result","range","isSubset","array1","array2","difference","cycle","a","indexOf","k","v","zipObject","mapIndexed","zipObjectDeepWith","keysToObject","zipObjectDeep","isFunction","isArray","times","encoder","flags","prefixes","list","size","map","take","separator","encode","decode","split","chunkBy","dotEncoder","slashEncoder","f","array","acc","_toConsumableArray","initial","head","tail","toggleElementBy","chunkByValue","group","isEqual","iteratee","callOrReturn","pull","replaceElementBy","toggleElement","includes","intersperse","isString","_$values2","_toArray","values","x0","xs","slice","reduceIndexed","b","replaceElement","_aspect","noRearg","convert","rearg","mutable","immutable","noCap","cap","getIn","hasIn","has","pickIn","pick","includesIn","inversions","mapKeys","extendOn","extend","defaultsOn","defaults","mergeOn","merge","setOn","set","unsetOn","curryN","unset","pullOn","updateOn","update","aspects","deprecate","mapValues","each","findIndexed","find","eachIndexed","pickByIndexed","pickBy","omitByIndexed","omitBy","mapValuesIndexed","_tree","flowMap","apply","_fp2","default","arguments","findApply","deepMap","obj","_map","undefined","is","isTraversable","index","collection","str","insertAtStringIndex","clone","splice","insertAtArrayIndex","compactMap","sizeBy","throws","tapError","_len","args","Array","_key","isNotNil","negate","isNil","isBlank","exists","isMultiple","append","overSome","isNotBlank","isBlankDeep","combinator","tree","leaves","_lang","overNone","ifElse","condition","onTrue","onFalse","isBoolean","boolIteratee","when","t","_len2","_key2","identity","unless","_len3","_key3","whenTruthy","Boolean","whenExists","unlessTruthy","maybeCall","boundMethod","method","bind","converge","converger","branches","over","composeApply","g","defer","comply","resolve","reject","promise","Promise","res","rej","uncurry","debounceAsync","deferred","debounced","debounce","flurry","fns","currier","_len4","_key4","arg","recurry","mapArgs","mapper","_len5","_key5","_array","isPlainObject","traverse","walk","next","pre","post","noop","parents","parentIndexes","findIndexedAsync","data","remaining","toPairs","_remaining","_remaining$","_slicedToArray","key","rest","then","walkAsync","preResult","stepResult","transformTree","cloneDeep","reduceTree","writeTreeNode","node","_ref","_ref2","_ref4","parent","_ref3","parentIndex","indexes","mapTree","writeNode","mapTreeLeaves","treeToArrayBy","treeToArray","leavesBy","treeLookup","buildIteratee","path","keyTreeByWith","transformer","groupIteratee","keyBy","matches","treeKeys","treeValues","treePath","build","reverse","flattenTree","propTreePath","prop","buildPath","flatLeaves","findNode","getResult","it","_len6","_key6","treeFind","_ref5","resolveOnTree","promises","_len7","_key7","newNode","all","transform","toArrayBy","toArray","lookup","keyByWith","mapLeaves","resolveOn","aspect","_ref$name","_ref$init","init","_ref$after","after","_ref$before","before","_ref$always","always","_ref$onError","onError","_f$state","state","error","catch","aspectSync","_ref2$name","_ref2$init","_ref2$after","_ref2$before","_ref2$always","_ref2$onError","_f$state2","status","processing","succeeded","failed","setStatus","params","clearStatus","timeout","setTimeout","concurrency","Error","logs","errors","subject","version","alternative","console","warn","trim","stack","isDeprecated","command","differentLast","normalCase","lastCase","_logic","functionLens","objectLens","fnToObj","objToFn","lens","lensProp","field","source","includeLens","lensOf","keys","view","construct","every","lensPair","stateLens","read","views","write","sets","setsWith","on","flip","off","binding","getEventValue","_len8","_key8","_defineProperty","targetBinding","domLens","checkboxValues","hover","onMouseEnter","onMouseLeave","focus","onFocus","onBlur","testRegex","regex","RegExp","test","makeRegex","options","text","anyWordToRegexp","makeAndTest","words","wordsToRegexp","matchWords","buildRegex","regexp","match","postings","matchAllWords","matchAnyWord","allMatches","regexStr","matched","exec","start","end","lastIndex","postingsForWords","string","word","highlightFromPostings","offset","posting","highlight","pattern","input","isRegExp","singleObject","singleObjectR","chunkObject","spread","isEmptyObject","compactObject","isNotEmptyObject","unwind","stripEmptyObjects","pickInto","renameProperty","target","renamePropertyOn","popProperty","stubArray","isFlatObject","unwindArray","flatMap","flattenObject","paths","output","cascade","unflattenObject","matchesSignature","signature","isObject","matchesSome","compareDeep","item","mapProp","getOrReturn","getOr","alias","aliasIn","defaultValue","defaultTo","cascadePropKey","cascadeIn","cascadeKey","unkeyBy","cascadeProp","keyName","simpleDiff","original","deltas","diff","simpleDiffArray","mergeArrays","diffArray","pickOn","objValue","srcValue","mergeAllArrays","mergeAllWith","mergeOverAllWith","invertByArray","stampKey","_extends","omitNil","omitNull","isNull","omitBlank","omitEmpty","mergeOverAll","mergeAll","customizer","getWith","mergeOverAllArrays","expandObject","findKeyIndexed","expandObjectBy","commonKeys","intersection","findKey","updateIfExistsOn","firstCommonKey","updateIfExists","updater","_updateMany","transforms","updatePathsOn","updateAllPathsOn","_matchesBy","updateAllPaths","updatePaths","combiner","criteria","callOrCompare","matchesBy","matchesBySome","some","_iterators","blankString","wrap","content","autoLabel","quote","parens","concatStrings","trimStrings","startCase","autoLabelOption","isUndefined","label","toSentenceWith","autoLabelOptions","lastSeparator","uniqueStringWith","toSentence","cachizer","initialKeys","cache","clear","uniqueString","countBy","crunchWhitespace","replace","promiseProps","props","asyncCall","flowWith","fn0","flowAsync","flowAsyncDeep","_async","forEach","_string","_object","_regex","_lens","async","conversion","logic","lang","iterators","greaterThanOne","lt","isPromise","_typeof","VERSION","global"],"mappings":"CAAA,SAAAA,EAAAC,GACA,iBAAAC,SAAA,iBAAAC,OACAA,OAAAD,QAAAD,EAAAG,QAAA,cACA,mBAAAC,eAAAC,IACAD,QAAA,aAAAJ,GACA,iBAAAC,QACAA,QAAA,YAAAD,EAAAG,QAAA,cAEAJ,EAAA,YAAAC,EAAAD,EAAA,cARA,CASCO,KAAA,SAAAC,GACD,mBCTA,IAAAC,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAT,QAGA,IAAAC,EAAAM,EAAAE,IACAC,EAAAD,EACAE,GAAA,EACAX,YAUA,OANAY,EAAAH,GAAAI,KAAAZ,EAAAD,QAAAC,IAAAD,QAAAQ,GAGAP,EAAAU,GAAA,EAGAV,EAAAD,QA2CA,OAtCAQ,EAAAM,EAAAF,EAGAJ,EAAAO,EAAAR,EAGAC,EAAAQ,EAAA,SAAAhB,EAAAiB,EAAAC,GACAV,EAAAW,EAAAnB,EAAAiB,IACAG,OAAAC,eAAArB,EAAAiB,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAV,EAAAiB,EAAA,SAAAzB,GACAoB,OAAAC,eAAArB,EAAA,cAAiD0B,OAAA,KAIjDlB,EAAAmB,EAAA,SAAA1B,GACA,IAAAiB,EAAAjB,KAAA2B,WACA,WAA2B,OAAA3B,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAO,EAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAU,EAAAC,GAAsD,OAAAV,OAAAW,UAAAC,eAAAnB,KAAAgB,EAAAC,IAGtDtB,EAAAyB,EAAA,GAIAzB,IAAA0B,EAAA,oBCnEAjC,EAAAD,QAAAM,waCAA,wDAAAE,EAAA,IACA2B,EAAA3B,EAAA,GACA4B,EAAA5B,EAAA,GACA6B,EAAA7B,EAAA,2HAGA,IAII8B,EAJa,SAACC,GAAD,OAAW,SAACC,GAAD,OAAY,SAACC,GAAD,OAAQ,SAACC,EAAGC,GAAJ,OAC9CJ,EAAMG,GAAKF,EAAOG,GAAKJ,EAAMI,GAAKH,EAAOE,GAAKD,EAAGC,EAAGC,MAChCC,CAAWC,UAAEC,QAERC,CADX,SAACL,GAAD,OAAQA,KAEpBM,EAAYH,UAAEG,UAAU,GACxBC,EAAOJ,UAAEK,UAAU,GAQZC,gBAAcN,UAAEO,MAAM,SAACC,EAAMX,GAAP,OAAaG,UAAES,QAAQZ,GAAGW,KAAKA,KAkCrDE,GA1BAC,UAAUL,EAAY,KAOtBM,cAAc,SAAChB,GAAD,OAAQ,SAACC,GAAD,OAAOG,UAAEa,KAAKb,UAAEc,OAAOlB,GAAKI,UAAEQ,KAAK,KAA5BR,CAAkCH,KAO/DkB,WAAWf,UAAEa,KACtBb,UAAEgB,QAAQ,SAACC,GAAD,OAAOA,IACjBjB,UAAEc,OAAO,SAACG,GAAD,OAAOA,EAAEC,OAAS,IAC3BlB,UAAEmB,QACFnB,UAAEoB,MAQOV,OAAOV,UAAEO,MAAM,SAACc,EAAKC,GAAN,OAAcA,EAAIC,QAAQF,OAkBhDG,GAjBOC,SAASzB,UAAEO,MAAM,SAACe,EAAKD,GAAN,OAAcC,EAAIC,QAAQF,MAC3CK,SAAS1B,UAAEO,MAAM,SAACe,EAAKD,GAEhC,OADAC,EAAIZ,KAAKW,GACFC,IAQEK,YAAY3B,UAAEO,MAAM,SAACqB,EAAMC,EAAIP,GAAX,OAC7BtB,UAAEa,KAAKb,UAAE8B,OAAOF,IAAO,EAAArC,EAAAwC,eAAcF,EAAIP,EAAIM,IAA7C5B,CAAqDsB,KAK9B7B,EAAqB,SAACI,EAAGC,GAAJ,OAF/B,SAACD,EAAGC,GAAJ,OAAUA,EAAE,GAAKD,EAAE,GAGhCmC,CAASnC,EAAGC,IAAMD,EAAGC,GAFN,SAACD,EAAGC,GAAJ,QAAYD,EAAE,GAAIG,UAAEiC,IAAIpC,EAAE0B,OAAOzB,MAEtBoC,CAAWrC,EAAGC,MAyC/BqC,GAhCAC,cAAcpC,UAAEa,KACzBb,UAAEqC,QAAQ,EAAG,IACbrC,UAAEsC,OACA,SAACC,EAAQC,GAAT,OACErC,EAAUoC,GAAQhB,OAChBC,EAAmBxB,UAAEmB,QAAQf,EAAKmC,IAAUC,UAWzCC,WAAWzC,UAAEO,MACtB,SAACmC,EAAQC,GAAT,OAA4D,IAAxC3C,UAAE4C,WAAWF,EAAQC,GAAQzB,SAQxC2B,QAAQ7C,UAAEO,MAAM,SAACuC,EAAGhE,GAAJ,OAAUgE,GAAGA,EAAEC,QAAQjE,GAAK,GAAKgE,EAAE5B,UAOnDiB,gBAAgBnC,UAAEO,MAAM,SAACyC,EAAGC,EAAGH,GAAP,OACjC9C,UAAEkD,WAAU,EAAA1D,EAAA2D,YAAWH,EAAGF,IAAI,EAAAtD,EAAA2D,YAAWF,EAAGH,OAenCM,GANAC,eAAelB,EAAc,SAACtC,GAAD,OAAOA,IAMpCuD,oBAAoBpD,UAAEO,MAAM,SAACV,EAAGC,GAAJ,OACrCE,UAAEsD,cAAczD,EAAGG,UAAEuD,WAAWzD,IAAME,UAAEwD,QAAQ3D,GAAKG,UAAEyD,MAAM3D,EAAGD,EAAEqB,QAAUpB,MAuBnE4D,GAfAC,QAAQP,EAAkBpD,UAAG,kBAAM,IAOnC4D,WAAW,SAACC,GAAD,OACpB7D,UAAEwC,MAAM,EAAGxC,UAAE8D,KAAKD,GAAQ,GAAGE,IAAI,SAAClE,GAAD,OAAOG,UAAEgE,KAAKnE,EAAGgE,MAOzCH,UAAU,SAACO,GAAD,OACnBC,OAAQ5D,EAAY2D,GACpBE,OAAQnE,UAAEoE,MAAMH,MAwBPI,GAhBAC,aAAaZ,EAAQ,KAOrBa,eAAeb,EAAQ,KASvBW,UAAUrE,UAAEO,MAAM,SAACiE,EAAGC,GAAJ,OAC3BzE,UAAEC,QAAQwE,MAENzE,UAAEsC,OACA,SAACoC,EAAK7E,GAAN,OACE2E,EAAExE,UAAEI,KAAKsE,GAAM7E,MAAf0B,OAAAoD,EACQ3E,UAAE4E,QAAQF,QADlBnD,OAAAoD,EAC4B3E,UAAEI,KAAKsE,KAAM7E,SADzC0B,OAAAoD,EAEQD,KAAM7E,QACdG,UAAE6E,KAAKJ,KACTzE,UAAE8E,KAAKL,OAsBJM,GAZAC,eAAehF,UAAEO,MAAM,SAACiE,EAAGC,GAAJ,OAChCJ,EACE,SAACY,EAAOrF,GAAR,OAAeI,UAAEkF,QAAQlF,UAAEmF,SAASX,EAAXxE,CAAcA,UAAEI,KAAK6E,IAASjF,UAAEmF,SAASX,EAAXxE,CAAcJ,KACrE6E,KASOM,kBAAkB/E,UAAEO,MAAM,SAACb,EAAO2B,EAAKC,GAAb,QAClC,EAAAhC,EAAA8F,cAAa1F,EAAO2B,EAAKC,GAAOtB,UAAEqF,KAAO3E,GAAMW,EAAKC,MAgE5CgE,GAxDAC,gBAAgBR,EAAgB/E,UAAEwF,UAsClCC,cAAczF,UAAEO,MAAM,SAACiE,EAAGlD,GAEnC,GAAItB,UAAEC,QAAQqB,IAAQtB,UAAE0F,SAASpE,GAAM,SAFI,IAAAqE,sDAAAC,CAIzB5F,UAAE6F,OAAOvE,IAAtBwE,EAJsCH,EAAA,GAI/BI,EAJ+BJ,EAAAK,MAAA,GAK3C,OAAO,EAAAxG,EAAAyG,eACL,SAACvB,EAAK7E,EAAGhC,GAAT,OACEA,IAAMkI,EAAG7E,UAATK,OAAAoD,EAAsBD,IAAK7E,OAA3B0B,OAAAoD,EAAoCD,KAAK,EAAApF,EAAA8F,cAAaZ,EAAGE,EAAK7G,EAAGkI,GAAKlG,MACvEiG,GACDC,KASOT,mBAAmBtF,UAAEO,MAAM,SAACiE,EAAG0B,EAAG5E,GAAP,OACpCtB,UAAE+D,IAAI,SAAC7F,GAAD,OAAQsG,EAAEtG,GAAKgI,EAAIhI,GAAIoD,MAQpB6E,iBAAiBnG,UAAEO,MAAM,SAACuC,EAAGoD,EAAG5E,GAAP,OAClCgE,EAAiBtF,UAAEkF,QAAQpC,GAAIoD,EAAG5E,8VC9RpC,wDAAA3D,EAAA,IACAyI,EAAAzI,EAAA,GAEA,IAAM0I,EAAUrG,UAAEsG,SAAUC,OAAO,IAC7BC,EAAUxG,UAAEsG,SAAUG,WAAW,IACjCC,EAAQ1G,UAAEsG,SAAUK,KAAK,IAkBlBC,QAAQP,EAAQ1H,IAOhBkI,QAAQR,EAAQS,IAOhBC,SAASV,EAAQW,KAOjBC,aAAaZ,EAAQb,SACrB0B,aAAalH,UAAEmH,QAAQ,SAACnE,GAAD,OAAUA,EAAV,MAAiBqD,GAkBxCe,WAAWZ,EAAQa,OAOnBC,aAAad,EAAQe,SAOrBC,UAAUhB,EAAQiB,MAOlBC,QAAQlB,EAAQmB,IAQhBC,UAAU5H,UAAE6H,OAAO,EAAGrB,EAAQsB,OAO9BC,SAASvB,EAAQnB,KAOjB2C,WAAWxB,EAAQyB,OAcnB3F,SAAS4F,UAAQC,UAC5B,SACA,SACA,gBAHoBD,CAIpBxB,EAAMpE,QACK8F,YAAYF,UAAQC,UAC/B,YACA,SACA,mBAHuBD,CAIvBxB,EAAM0B,WACKC,OAAOH,UAAQC,UAC1B,OACA,SACA,cAHkBD,CAIlBxB,EAAM2B,MAOKlF,aAAauD,EAAM3C,IAOnBuE,cAAc5B,EAAM6B,KAOpBC,cAAc9B,EAAM2B,KAOpBpC,gBAAgBS,EAAMpE,OAOtBmG,gBAAgB/B,EAAMgC,OAOtBC,gBAAgBjC,EAAMkC,OAOtBC,mBAAmBnC,EAAM0B,4KCvLtC,wDAAAzK,EAAA,IACAmL,EAAAnL,EAAA,GAOaoL,UAAU,kBAAY/I,UAAE+D,IAAI/D,UAAEa,KAAFmI,MAAAC,EAAAC,QAAAC,aAO9BC,YAAYpJ,UAAEO,MAAM,SAACiE,EAAGlD,GAAJ,OAAYtB,UAAEmF,SAASX,EAAXxE,CAAcA,UAAEuI,KAAK/D,EAAGlD,MAP5D,IAcIyC,QAAM/D,UAAEO,MAAM,SAACiE,EAAG3E,GAAJ,OACtBG,UAAEwD,QAAQ3D,GAAKG,UAAE+D,IAAM/D,UAAEoI,WAAW9B,SAAUK,KAAK,GAApD,CAA6DnC,EAAG3E,KAQvDwJ,YAAUrJ,UAAEO,MAAM,SAACX,EAAI0J,GAAL,IAAUC,EAAVJ,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAiBpF,EAAK0F,EAAtBN,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAA2BO,gBAA3B,OAC3BH,EAAK,SAACtI,GAAD,OAAQwI,EAAGxI,GAAKoI,EAAQzJ,EAAIA,EAAGqB,GAAIsI,EAAME,GAAMxI,GAAIqI,KAiB/CvH,gBAAgB/B,UAAEO,MAAM,SAACoJ,EAAOtI,EAAKuI,GAAb,OACjC5J,UAAE0F,SAASkE,GAfa,SAACD,EAAOtI,EAAKwI,GAAb,OACxBA,EAAI7D,MAAM,EAAG2D,GAAStI,EAAMwI,EAAI7D,MAAM2D,GAelCG,CAAoBH,EAAOtI,EAAKuI,GAdb,SAACD,EAAOtI,EAAKC,GACpC,IAAIiB,EAASvC,UAAE+J,MAAMzI,GAErB,OADAiB,EAAOyH,OAAOL,EAAO,EAAGtI,GACjBkB,EAYH0H,CAAmBN,EAAOtI,EAAKuI,KAQ1BM,aAAalK,UAAEO,MAAM,SAACX,EAAIgK,GAAL,OAC9B5J,UAAEa,KAAKb,UAAE+D,IAAInE,GAAKI,UAAES,QAApBT,CAA6B4J,KAQlBO,SAASnK,UAAEO,MAAM,SAACX,EAAIgK,GAAL,OAC5B5J,UAAEa,KAAKb,UAAEc,OAAOlB,GAAKI,UAAE8D,KAAvB9D,CAA6B4J,8LCjE/B,wDAAAjM,EAAA,IACAmL,EAAAnL,EAAA,GAKWyM,SAAS,SAACvK,GACnB,MAAMA,GAMGwK,WACT,SAAC7F,GAAD,OACA,SAACvD,GAAe,QAAAqJ,EAAAnB,UAAAjI,OAATqJ,EAASC,MAAAF,EAAA,EAAAA,EAAA,KAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAATF,EAASE,EAAA,GAAAtB,UAAAsB,GAEd,MADAjG,gBAAEvD,GAAFM,OAAQgJ,IACFtJ,IAXH,IAaIyJ,aAAW1K,UAAE2K,OAAO3K,UAAE4K,OA8BtBC,GAvBAC,SAASJ,EAOTK,aAAa,SAAClL,GAAD,OAAQA,OAASqB,OAAS,GAOvC8J,SAAShL,UAAEO,MAAM,SAACV,EAAGC,GAAJ,OAAUA,EAAID,IAS/BgL,UAAU7K,UAAEiL,UACrBjL,UAAE4K,MACF5K,UAAEkF,QAAQ,IACVlF,UAAEkF,YACFlF,UAAEkF,eAQOgG,aAAalL,UAAE2K,OAAOE,GAOtBM,cAAc,SAACC,GAAD,OAAgB,SAACvL,GAAD,OACvCuL,EAAWP,GAAS,EAAA/B,EAAAuC,QAAOC,OAAOzL,yKC1EpC,wDAAAlC,EAAA,IACA2B,EAAA3B,EAAA,GACA4N,EAAA5N,EAAA,GAOa6N,WAAWxL,UAAEa,KAAKb,UAAEiL,SAAUjL,UAAE2K,QAAtC,IAUIc,WAASzL,UAAE6H,OAAO,EAAG,SAAC6D,EAAWC,EAAQC,GAApB,QAAAtB,EAAAnB,UAAAjI,OAAgCrB,EAAhC2K,MAAAF,EAAA,EAAAA,EAAA,KAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAgC5K,EAAhC4K,EAAA,GAAAtB,UAAAsB,GAAA,OARb,SAAC5K,GAAD,OACjBG,UAAE6L,UAAUhM,IAAMG,UAAE4K,MAAM/K,GAAK,kBAAMA,GAAIG,UAAEmF,SAAStF,GAQpDiM,CAAaJ,GAAb1C,WAAAQ,EAA2B3J,GACvBuF,6BAAauG,GAAbpK,OAAwB1B,IACxBuF,6BAAawG,GAAbrK,OAAyB1B,MAQpBkM,SAAO/L,UAAE6H,OAAO,EAAG,SAAC6D,EAAWM,GAAZ,QAAAC,EAAA9C,UAAAjI,OAAkBrB,EAAlB2K,MAAAyB,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAkBrM,EAAlBqM,EAAA,GAAA/C,UAAA+C,GAAA,OAC5BT,gBAAOC,EAAWM,EAAGhM,UAAEmM,UAAvB5K,OAAoC1B,MAQ3BuM,WAASpM,UAAE6H,OAAO,EAAG,SAAC6D,EAAWlH,GAAZ,QAAA6H,EAAAlD,UAAAjI,OAAkBrB,EAAlB2K,MAAA6B,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAkBzM,EAAlByM,EAAA,GAAAnD,UAAAmD,GAAA,OAC9Bb,gBAAOC,EAAW1L,UAAEmM,SAAU3H,GAA9BjD,OAAoC1B,MAM3B0M,aAAaR,EAAKS,SAKlBC,aAAaV,EAAKjB,UAKlB4B,eAAeN,EAAOI,0OCxDjC,wDAAA7O,EAAA,IAOWgP,YAAY,SAAC/M,GAAD,QAAA0K,EAAAnB,UAAAjI,OAAQqJ,EAARC,MAAAF,EAAA,EAAAA,EAAA,KAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAQF,EAARE,EAAA,GAAAtB,UAAAsB,GAAA,OAAiBzK,UAAEuD,WAAW3D,IAAOA,eAAM2K,IAOvDnF,eAAe,SAACxF,GAAD,QAAAqM,EAAA9C,UAAAjI,OAAQqJ,EAARC,MAAAyB,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAQ3B,EAAR2B,EAAA,GAAA/C,UAAA+C,GAAA,OAAkBlM,UAAEuD,WAAW3D,GAAMA,eAAM2K,GAAQ3K,GAOlEgN,cAAc,SAACC,EAAQ7N,GAAT,OAAoBA,EAAO6N,GAAQC,KAAK9N,IAOtD+N,WACT,SAACC,EAAWC,GAAZ,OACA,kBACED,EAAUhN,UAAEkN,KAAKD,GAAPjE,WAAAQ,EAAAL,cAxBP,IA0BIgE,iBAAe,SAAC3I,EAAG4I,GAAJ,OAAU,SAACvN,GAAD,OAAO2E,EAAE4I,EAAEvN,GAAJ2E,CAAQ3E,KAaxCwN,GALAC,SAASH,EAKTE,QAAQ,WACjB,IAAIE,SACAC,SACAC,EAAU,IAAIC,QAAQ,SAACC,EAAKC,GAC9BL,EAAUI,EACVH,EAASI,IAEX,OACEL,UACAC,SACAC,aAmCOI,GA5BAC,gBAAgB,SAAChP,EAAG0F,GAC7B,IAAIuJ,EAAWV,IACXW,EAAYhO,UAAEiO,SAASnP,EAAG,WAC5BiP,EAASR,QAAQ/I,2BACjBuJ,EAAWV,MAEb,OAAO,WAEL,OADAW,0BACOD,EAASN,UAaTS,SART,SAAC1J,GAAD,OACA,mBAAA6H,EAAAlD,UAAAjI,OAAIiN,EAAJ3D,MAAA6B,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAI6B,EAAJ7B,GAAAnD,UAAAmD,GAAA,OACEtM,UAAE6H,OAAOsG,EAAI,GAAGjN,OAAQsD,eAAK2J,KAMbC,CAAQpO,UAAEa,MAOnBgN,UACT,SAACjO,GAAD,OACA,mBAAAyO,EAAAlF,UAAAjI,OAAIqJ,EAAJC,MAAA6D,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAI/D,EAAJ+D,GAAAnF,UAAAmF,GAAA,OACE/D,EAAKjI,OAAO,SAAC1C,EAAI2O,GAAL,OAAa3O,EAAG2O,IAAM3O,MAO3B4O,UAAU,SAAC1P,EAAGc,GAAJ,OAAWI,UAAE6H,OAAO/I,EAAG+O,EAAQjO,KAOzC6O,UAAUzO,UAAEO,MACrB,SAACmO,EAAQ9O,GAAT,OACE,mBAAA+O,EAAAxF,UAAAjI,OAAIrB,EAAJ2K,MAAAmE,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAI/O,EAAJ+O,GAAAzF,UAAAyF,GAAA,OACEhP,sIAAMC,EAAEkE,IAAI2K,+3BCxGlB/Q,EAAA,IACA6B,EAAA7B,EAAA,GACAkR,EAAAlR,EAAA,iLAOO,IAAI+L,kBAAgB,SAAC7J,GAAD,OAAOG,UAAEwD,QAAQ3D,IAAMG,UAAE8O,cAAcjP,IAOvDkP,aAAW,SAAClP,GAAD,OAAO6J,EAAc7J,KAAOG,UAAEC,QAAQJ,IAAMA,GAOvDmP,SACT,SADSA,IACT,IAACC,EAAD9F,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAQ4F,EAAR,OACA,SAACG,GAAD,IAAMC,EAANhG,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAanJ,UAAEoP,KAAMC,EAArBlG,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,MAAmCmG,EAAnCnG,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,aACA,SAACkC,EAAM1B,GAAP,OACEuF,EAAI7D,EAAM1B,EAAO0F,EAASC,KAC1B,EAAA9P,EAAA8I,aACE0G,EAAKC,EAALD,CAAWE,EAAKC,GAAO9D,GAAvB9J,OAAAoD,EAAgC0K,KAAW1F,GAA3CpI,OAAAoD,EAAqD2K,KACrDL,EAAK5D,EAAM1B,EAAO0F,EAASC,SAE7BH,EAAK9D,EAAM1B,EAAO0F,EAASC,MASpBC,qBAAmB,SAAnBA,EAAoB/K,EAAGgL,GAAsC,IAAhCC,EAAgCtG,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAApBnJ,UAAE0P,QAAQF,GAC5D,GAAKC,EAAUvO,OAAf,CADsE,IAAAyO,EAAA/J,EAE1C6J,GAF0CG,EAAAC,EAAAF,EAAA,MAEhEG,EAFgEF,EAAA,GAE3DvO,EAF2DuO,EAAA,GAElDG,EAFkDJ,EAAA3J,MAAA,GAGtE,OAAO0H,QAAQH,QAAQ/I,EAAEnD,EAAKyO,EAAKN,IAAOQ,KAAK,SAACzN,GAAD,OAC7CA,EAASlB,EAAM0O,EAAK7O,OAASqO,EAAiB/K,EAAGgL,EAAMO,QAAQvG,MASxDyG,cACT,SADSA,IACT,IAAChB,EAAD9F,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAQ4F,EAAR,OACA,SAACG,GAAD,IAAMC,EAANhG,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAanJ,UAAEoP,KAAMC,EAArBlG,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,MAAmCmG,EAAnCnG,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,aACA,SAACkC,EAAM1B,GAAP,OACE+D,QAAQH,QAAQ2B,EAAI7D,EAAM1B,EAAO0F,EAASC,IACvCU,KACC,SAACE,GAAD,OACEA,GACAX,EACEU,EAAUhB,EAAVgB,CACEf,EACAC,GACC9D,GAHH9J,OAAAoD,EAGY0K,KACT1F,GAJHpI,OAAAoD,EAIa2K,KAEbL,EAAK5D,EAAM1B,EAAO0F,EAASC,UAGhCU,KACC,SAACG,GAAD,OAAgBA,GAAchB,EAAK9D,EAAM1B,EAAO0F,EAASC,QAQtDc,kBAAgB,eAACnB,EAAD9F,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAQ4F,EAAR,OACzB/O,UAAEO,MAAM,SAACiE,EAAG3E,GACV,IAAI0C,EAASvC,UAAEqQ,UAAUxQ,GAEzB,OADAmP,EAAKC,EAALD,CAAWxK,EAAXwK,CAAczM,GACPA,KAQA+N,eAAa,eAACrB,EAAD9F,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAQ4F,EAAR,OACtB/O,UAAEO,MAAM,SAACiE,EAAGjC,EAAQ8I,GAIlB,OAHA2D,EAAKC,EAALD,CAAW,WAAU,QAAA1E,EAAAnB,UAAAjI,OAANrB,EAAM2K,MAAAF,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAN5K,EAAM4K,GAAAtB,UAAAsB,GACnBlI,EAASiC,gBAAEjC,GAAFhB,OAAa1B,KADxBmP,CAEG3D,GACI9I,KAOAgO,kBACT,eAACtB,EAAD9F,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAQ4F,EAAR,OACA,SAACyB,EAAM7G,EAAP8G,EAAAC,GAAkE,IAAAC,EAAA/K,EAAA6K,GAAnDG,EAAmDD,EAAA,GAAxCtB,EAAwCsB,EAAA3K,MAAA,GAAA6K,EAAAjL,EAAA8K,GAA7BI,EAA6BD,EAAA,GAAbE,EAAaF,EAAA7K,MAAA,GAChEiJ,EAAK2B,EAAQE,EAAazB,EAAS0B,GAASpH,GAAS6G,IAQ9CQ,YAAU,eAAC/B,EAAD9F,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAQ4F,EAAUkC,EAAlB9H,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAA8BoH,EAActB,GAA5C,OACnBjP,UAAEO,MACA,SAACmO,EAAQrD,GAAT,OACE+E,EAAcnB,EAAdmB,CAAoB,SAACI,EAAM3S,EAAGwR,GAAqB,QAAApD,EAAA9C,UAAAjI,OAATqJ,EAASC,MAAAyB,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAT3B,EAAS2B,EAAA,GAAA/C,UAAA+C,GAC7CmD,EAAQnO,QACV+P,gBAAUvC,gBAAO8B,EAAM3S,EAAGwR,GAAhB9N,OAA4BgJ,IAAO1M,EAAGwR,GAAhD9N,OAA4DgJ,KAFhE6F,CAGG1B,EAAOrD,OAQL6F,kBAAgB,eAACjC,EAAD9F,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAQ4F,EAAUkC,EAAlB9H,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAA8BoH,EAActB,GAA5C,OACzBjP,UAAEO,MAAM,SAACmO,EAAQrD,GAAT,OAGN2F,EAAQ/B,EAAMgC,EAHR,CAGmB,SAACT,GAAD,OAAWvB,EAAKuB,GAAQA,EAAO9B,EAAO8B,IAAQnF,MAQhE8F,kBAAgB,eAAClC,EAAD9F,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAQ4F,EAAR,OACzB/O,UAAEO,MAAM,SAACX,EAAIyL,GAAL,OACNiF,EAAWrB,EAAXqB,CAAiB,SAAC1R,GAAD,QAAAyN,EAAAlD,UAAAjI,OAAOqJ,EAAPC,MAAA6B,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAO/B,EAAP+B,EAAA,GAAAnD,UAAAmD,GAAA,OAAgB,EAAAuC,EAAAnO,MAAKd,eAAM2K,GAAO3L,OAAQyM,MAQpD+F,gBAAc,eAACnC,EAAD9F,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAQ4F,EAAR,OAAqBoC,EAAclC,EAAdkC,CAAoB,SAACtR,GAAD,OAAOA,KAU9DwR,aAAW,eAACpC,EAAD9F,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAQ4F,EAAR,OACpB/O,UAAEO,MAAM,SAACX,EAAIyL,GAAL,OACNiF,EAAWrB,EAAXqB,CACE,SAAC1R,EAAG4R,GAAJ,QAAAnC,EAAAlF,UAAAjI,OAAaqJ,EAAbC,MAAA6D,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAa/D,EAAb+D,EAAA,GAAAnF,UAAAmF,GAAA,OAAuBW,EAAKuB,GAAQ5R,GAAI,EAAAiQ,EAAAnO,MAAKd,gBAAG4Q,GAAHjP,OAAYgJ,IAAO3L,OAEhEyM,MASKC,WAAS,eAAC2D,EAAD9F,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAQ4F,EAAR,OAAqBsC,EAASpC,EAAToC,CAAe,SAACxR,GAAD,OAAOA,KAOpDyR,eAAa,eAACrC,EAAD9F,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAQ4F,EAAUwC,EAAlBpI,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAkCnJ,UAAEmM,SAApC,OACtBnM,UAAEO,MAAM,SAACiR,EAAMnG,GAAP,OACNrL,UAAEsC,OACA,SAAC+I,EAAMmG,GAAP,OAAgB,EAAAhS,EAAA8I,aAAYiJ,EAAcC,GAAOvC,EAAK5D,KACtDA,EACAmG,MASKC,kBAAgB,eAACxC,EAAD9F,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAQ4F,EAAR,OACzB/O,UAAEO,MAAM,SAACmR,EAAaC,EAAe9R,GAA7B,OACNG,UAAEa,KACAsQ,EAAclC,EAAdkC,CAAoBnR,UAAEmF,SAASwM,IAC/B3R,UAAEoB,KACFpB,UAAE4R,MAAM5R,UAAEmM,UACVnM,UAAEoI,UAAU,SAACnD,GAAD,OACVmL,EAAcnB,EAAdmB,CAAoB,SAACI,GACnB,IAAIqB,EAAU7R,UAAEmF,SAASwM,EAAX3R,CAA0BwQ,KAAUvL,EAClDyM,EAAYlB,EAAMqB,EAAS5M,IAC1BpF,KARPG,CAUEH,MAUKiS,aAAW,SAACjS,EAAGhC,EAAGkI,EAAI0D,GAAX,OAAmB5L,GAAnB0D,OAAAoD,EAAyB8E,KAOpCsI,eAAa,SAAClS,EAAGhC,EAAGkI,GAAP,OAAelG,GAAf0B,OAAAoD,EAAqBoB,KAOlCiM,aACT,eAACC,EAAD9I,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAS2I,EAAUpO,EAAnByF,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAA6B7E,aAA7B,OACA,kBACGZ,EAAQQ,QAAUR,GAASuO,0BAAeC,aAepCC,GARAC,eAAe,SAACC,GAAD,OACxBL,EAAShS,UAAEa,KAAKkR,EAAY/R,UAAE+D,IAAIsO,IAAQ9N,iBAOjC4N,cACT,eAAClD,EAAD9F,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAQ4F,EAAR,OACA,eAACuD,EAADnJ,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAa6I,IAAb,OACE1B,EAAWrB,EAAXqB,CACE,SAAC/N,EAAQiO,GAAT,QAAA7B,EAAAxF,UAAAjI,OAAkBrB,EAAlB2K,MAAAmE,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAkB/O,EAAlB+O,EAAA,GAAAzF,UAAAyF,GAAA,OAAwB5O,UAAE2H,KAAK2K,gBAAU9B,GAAVjP,OAAmB1B,KAAK2Q,EAAMjO,WAIxDgQ,eAAa,eAACtD,EAAD9F,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAQ4F,EAAR,OAAqB/O,UAAEwN,OAAOyB,IAoBzCuD,aAAW,kBAlBP,SAACvD,EAAMwD,GAAP,OAAqB,SAACC,EAAIrH,GACzC,IAAI9I,SAOJ,OANAyM,EAAKC,EAALD,CAAW,SAACwB,GAAkB,QAAAmC,EAAAxJ,UAAAjI,OAATqJ,EAASC,MAAAmI,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAATrI,EAASqI,EAAA,GAAAzJ,UAAAyJ,GAC5B,GAAI5S,UAAEmF,SAASuN,GAAX1J,WAAAQ,GAAegH,GAAfjP,OAAwBgJ,IAE1B,OADAhI,EAASkQ,GAAWjC,GAAXjP,OAAoBgJ,KAFjCyE,CAKG3D,GACI9I,GAUoCsQ,CAArB1J,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAQ4F,EAA4B,SAAA+D,GAAA,OAAAjD,EAAAiD,EAAA,SASjDC,kBACT,eAAC9D,EAAD9F,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAQ4F,EAAUkC,EAAlB9H,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAA8BoH,EAActB,GAA5C,OACA,SAAC5D,GACC,IAAI2H,KAOJ,OANAhE,EAAKC,EAALD,CAAW,SAACwB,GAAkB,QAAAyC,EAAA9J,UAAAjI,OAATqJ,EAASC,MAAAyI,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAT3I,EAAS2I,EAAA,GAAA/J,UAAA+J,GACxB1C,EAAKR,MAEPgD,EAAStS,KAAK8P,EAAKR,KAAK,SAACmD,GAAD,OAAalC,gBAAUkC,GAAV5R,OAAsBgJ,QAH/DyE,CAIG3D,GAEIrL,UAAEC,QAAQ+S,GAAY3H,EAAOqC,QAAQ0F,IAAIJ,GAAUhD,KAAK,kBAAM3E,MAS9DA,OAAO,eAChB4D,EADgB9F,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GACT4F,EACPwC,EAFgBpI,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAEAnJ,UAAEmM,SAClB8E,EAHgB9H,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAGJoH,EAActB,GAHV,OAKhBD,KAAMA,EAAKC,GACXgB,UAAWA,EAAUhB,GACrBoE,UAAWjD,EAAcnB,GACzB3M,OAAQgO,EAAWrB,GACnBqE,UAAWnC,EAAclC,GACzBsE,QAASnC,EAAYnC,GACrB3D,OAAQA,EAAO2D,GACfoC,SAAUA,EAASpC,GACnBuE,OAAQlC,EAAWrC,EAAMsC,GACzBkC,UAAWhC,EAAcxC,GACzBF,SAAUE,EACV9N,QAASgR,EAAYlD,GACrBsD,WAAYA,EAAWtD,GACvBlL,IAAKiN,EAAQ/B,EAAMgC,GACnByC,UAAWxC,EAAcjC,EAAMgC,GAC/B0C,UAAWZ,EAAc9D,EAAMgC,GAC/BuB,SAAUA,EAASvD,2HC7TrB,wDAAAtR,EAAA,IACA6B,EAAA7B,EAAA,GACA4N,EAAA5N,EAAA,mPA8BO,IAAIiW,WACT,SAAAnD,GAAA,IAAAoD,EAAApD,EACErS,YADFoL,IAAAqK,EACS,SADTA,EAAAC,EAAArD,EAEEsD,YAFFvK,IAAAsK,EAES9T,UAAEoP,KAFX0E,EAAAE,EAAAvD,EAGEwD,aAHFzK,IAAAwK,EAGUhU,UAAEoP,KAHZ4E,EAAAE,EAAAzD,EAIE0D,cAJF3K,IAAA0K,EAIWlU,UAAEoP,KAJb8E,EAAAE,EAAA3D,EAKE4D,cALF7K,IAAA4K,EAKWpU,UAAEoP,KALbgF,EAAAE,EAAA7D,EAME8D,eANF/K,IAAA8K,EAMYlK,SANZkK,EAAA,OASA,SAAC9P,GAAM,IAAAgQ,EACgBhQ,EAAfiQ,aADDjL,IAAAgL,OAELT,EAAKU,GAEL,IAAI5U,OACDzB,EADC,WACc,QAAAkM,EAAAnB,UAAAjI,OAANqJ,EAAMC,MAAAF,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAANF,EAAME,GAAAtB,UAAAsB,GACd,IAAIlI,SACAmS,SACJ,OAAOhH,QAAQH,UACZyC,KAAK,kBAAMmE,EAAO5J,EAAMkK,KACxBzE,KAAK,kBAAMxL,iBAAK+F,MAChByF,KAAK,SAACpR,GACL2D,EAAS3D,IAEVoR,KAAK,kBAAMiE,EAAM1R,EAAQkS,EAAOlK,KAChCoK,MAAM,SAAC1T,GAAD,OAAOsT,EAAQtT,EAAGwT,EAAOlK,KAC/BoK,MAAM,SAAC1T,GACNyT,EAAQzT,IAET+O,KAAK,kBAAMqE,EAAOI,EAAOlK,KACzByF,KAAK,WACJ,GAAI0E,EAAO,MAAMA,IAElB1E,KAAK,kBAAMzN,MAIlB,OADA1C,EAAEzB,GAAMqW,MAAQA,EACT5U,EAAEzB,KAQFwW,eACT,SAAAlE,GAAA,IAAAmE,EAAAnE,EACEtS,YADFoL,IAAAqL,EACS,SADTA,EAAAC,EAAApE,EAEEqD,YAFFvK,IAAAsL,EAES9U,UAAEoP,KAFX0F,EAAAC,EAAArE,EAGEuD,aAHFzK,IAAAuL,EAGU/U,UAAEoP,KAHZ2F,EAAAC,EAAAtE,EAIEyD,cAJF3K,IAAAwL,EAIWhV,UAAEoP,KAJb4F,EAAAC,EAAAvE,EAKE2D,cALF7K,IAAAyL,EAKWjV,UAAEoP,KALb6F,EAAAC,EAAAxE,EAME6D,eANF/K,IAAA0L,EAMY9K,SANZ8K,EAAA,OASA,SAAC1Q,GAAM,IAAA2Q,EACgB3Q,EAAfiQ,aADDjL,IAAA2L,OAELpB,EAAKU,GAEL,IAAI5U,OACDzB,EADC,WACc,QAAA6N,EAAA9C,UAAAjI,OAANqJ,EAAMC,MAAAyB,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAN3B,EAAM2B,GAAA/C,UAAA+C,GACd,IACEiI,EAAO5J,EAAMkK,GACb,IAAIlS,EAASiC,iBAAK+F,IAElB,OADA0J,EAAM1R,EAAQkS,EAAOlK,GACdhI,EACP,MAAOtB,GAEP,MADAsT,EAAQtT,EAAGwT,EAAOlK,GACZtJ,EAPR,QASEoT,EAAOI,EAAOlK,MAKpB,OADA1K,EAAEzB,GAAMqW,MAAQA,EACT5U,EAAEzB,KAUTsW,EAAQ,eAACrN,EAAD8B,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAU7B,aAAV,OACVsM,GACEG,KAAM1M,GAASqN,MAAO,OACtBH,SAAS,EAAA/U,EAAAkI,OAAM,SACftJ,KAAM,WAQNgX,EAAS,eAAC/N,EAAD8B,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAU7B,aAAV,OACXsM,GACEG,KAAM1M,GACJ+N,OAAQ,KACRC,YAAY,EACZC,WAAW,EACXC,QAAQ,EAERC,UANW,SAMD3V,GACRrC,KAAK4X,OAASvV,EACdrC,KAAK+X,OAAe,WAAN1V,EACdrC,KAAK8X,UAAkB,cAANzV,EACjBrC,KAAK6X,WAAmB,eAANxV,KAGtBsU,OAdK,SAcEsB,EAAQhB,GACbA,EAAMe,UAAU,eAElBvB,MAjBK,SAiBC1R,EAAQkS,GACZA,EAAMe,UAAU,cAElBjB,SAAS,EAAAhJ,EAAAlB,UAAS,SAACpJ,EAAGwT,GACpBA,EAAMe,UAAU,YAElBpX,KAAM,YAENsX,EAAc,eAACC,EAADxM,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAW,IAAX,OAChByK,GACES,OADK,SACEI,GACW,OAAZkB,GACFC,WAAW,WACTnB,EAAMe,UAAU,OACfG,IAGPvX,KAAM,iBAGNyX,EAAc,kBAChBjC,GACEO,OADK,SACEsB,EAAQhB,GACb,GAAIA,EAAMY,WACR,MAAMS,MAAM,gCAGhB1X,KAAM,iBA2BC8J,WAMT6N,KAhGS,eAAC1O,EAAD8B,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAU7B,aAAV,OACTsM,GACEG,KAAM1M,GAAS0O,UACf9B,MAAO,SAAC1R,EAAQkS,GAAT,OAAmBA,EAAMsB,KAAKrV,KAAK6B,IAC1CnE,KAAM,UAmGRsW,QAOAsB,OAlGW,eAAC3O,EAAD8B,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,GAAU7B,aAAV,OACXsM,GACEG,KAAM1M,GAAS2O,YACfzB,QAAS,SAACtT,EAAGwT,GAAJ,OAAcA,EAAMuB,OAAOtV,KAAKO,IACzC7C,KAAM,YAqGRgX,SAOAjN,UAlDc,SAAC8N,EAASC,EAASC,GAAnB,OACdvB,GACET,OAAQ,kBACNiC,QAAQC,KAAR,IACOJ,EADP,mBACiCC,YAAoBA,EAAY,KAC7DC,mBAAgCA,EAAhC,IAAkD,IAFtD,IAGMnW,UAAEsW,MAAMR,QAAQS,OAAS,IAAInS,MAAM,MAAM,MAEjD2P,KAPS,SAOJU,GACHA,EAAM+B,cAAe,EACrB/B,EAAMwB,QAAUA,EAChBxB,EAAMyB,QAAUA,EAChBzB,EAAM0B,YAAcA,MA6CxBT,cAOAG,cAOAY,QA/EY,SAACpP,EAAQsO,GAAT,OACZ3V,UAAEa,KACAuU,EAAO/N,GACPqO,EAAYC,GACZE,IACAnB,EAAMrN,4GCxMV,wDAAA1J,EAAA,IAOW+Y,gBAAgB,SAACC,EAAYC,GAAb,OAA0B,SAAClS,EAAK7G,EAAGgG,GAAT,OACnDhG,IAAMgG,EAAK3C,OAAS,EAChBlB,UAAEmF,SAASyR,EAAX5W,CAAqB0E,EAAK7G,EAAGgG,GAC7B7D,UAAEmF,SAASwR,EAAX3W,CAAuB0E,EAAK7G,EAAGgG,utBC6BrClG,EAAA,IACA6B,EAAA7B,EAAA,GACAkR,EAAAlR,EAAA,GACAkZ,EAAAlZ,EAAA,2HAOWmZ,eACT,SAACzV,GAAD,OACA,WACE,IAAK8H,UAAEjI,OAAQ,OAAOG,EACtBA,4CAMO0V,aAAa,SAAC1V,GAAD,OACtB1C,IAAK,kBAAM0C,GAOXsG,IARgC,SAQ5B9H,GACFwB,EAAMxB,KASCmX,UAAU,SAACpX,GAAD,OACnBjB,IAAKiB,EACL+H,IAAK/H,IAMIqX,UACT,SAACC,GAAD,OACA,kBACE/N,UAAOjI,OAASgW,EAAKvP,IAALwB,UAAAjI,QAAA,OAAAsI,EAAAL,UAAA,IAAsB+N,EAAKvY,QAvCxC,IAiDIwY,aAAW,SAACC,EAAOC,GAAR,OACpB1Y,IAAK,kBAAMqB,UAAErB,IAAIyY,EAAOC,IACxB1P,IAFwC,SAEpC9I,IACF,EAAAW,EAAAkI,OAAM0P,EAAOvY,EAAOwY,MA4BbC,GAfAC,SAAS,SAACvY,GAAD,OAClBgB,UAAEsC,OACA,SAACqL,EAAKmC,GAEJ,OADAnC,EAAImC,GAAOqH,EAASrH,EAAK9Q,GAClB2O,MAGT3N,UAAEwX,KAAKxY,KAQAsY,cAAc,SAACzY,GAAD,QAAAyL,EAAAnB,UAAAjI,OAAWgW,EAAX1M,MAAAF,EAAA,EAAAA,EAAA,KAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAWyM,EAAXzM,EAAA,GAAAtB,UAAAsB,GAAA,OACvB9L,IAAK,kBAAMqB,UAAEwF,SAAS3G,EAAO4Y,eAAQP,KAErCvP,IAAK,SAAC9H,GAAD,OAAO8H,gBAAI3H,UAAEoB,MAAK,EAAAyN,EAAA9J,kBAAiBlF,EAAGhB,EAAO4Y,eAAQP,MAA9C3V,OAA0D2V,QAMpEQ,EAAY,mBAAAzL,EAAA9C,UAAAjI,OAAIqJ,EAAJC,MAAAyB,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAI3B,EAAJ2B,GAAA/C,UAAA+C,GAAA,OACd3B,EAAK,GACDvK,UAAE2X,MAAM3X,UAAEuD,WAAYgH,GAHb,SAAC5L,EAAKgJ,GAAN,OAAiBhJ,MAAKgJ,QAI7BiQ,aAAYrN,GACZ4M,eAAY5M,IACd,EAAAsM,EAAA9K,MAAK/L,UAAEwD,QAASqU,EAAhB,CAA2BtN,EAAK,KAS3BkN,SAAO,kBAPP,SAACP,GAAD,OAAWA,EAAKvY,IAAMuY,EAAKvY,MAAQuY,IAOfY,CAAKJ,4BAYzB/P,GALAoQ,QACT,mBAAA1L,EAAAlD,UAAAjI,OAAIgW,EAAJ1M,MAAA6B,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAI4K,EAAJ5K,GAAAnD,UAAAmD,GAAA,OACA,kBACEmL,eAAQP,KAEKlX,UAAE6H,OAAO,EAAG,SAACxG,GAAD,QAAAgN,EAAAlF,UAAAjI,OAASgW,EAAT1M,MAAA6D,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAS4I,EAAT5I,EAAA,GAAAnF,UAAAmF,GAAA,OADjB,SAACjN,EAAK6V,GAAN,OAAgBA,EAAKvP,IAAMuP,EAAKvP,IAAItG,GAAO6V,EAAK7V,GACb2W,CAAM3W,EAAKqW,eAAaR,eAKhE,IAAIe,SAAOjY,UAAE6H,OAClB,EACA,SAACxG,GAAD,QAAAsN,EAAAxF,UAAAjI,OAASgW,EAAT1M,MAAAmE,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAASsI,EAATtI,EAAA,GAAAzF,UAAAyF,GAAA,OACE,kBACEjH,gBAAItG,GAAJE,OAAY2V,OAMPgB,aAAWlY,UAAEO,MACtB,SAACiE,GAAD,QAAAmO,EAAAxJ,UAAAjI,OAAOgW,EAAP1M,MAAAmI,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAOsE,EAAPtE,EAAA,GAAAzJ,UAAAyJ,GAAA,OACE,SAAC/S,GAAD,OACE8H,gBAAI3H,UAAEmF,SAASX,EAAXxE,CAAcH,IAAlB0B,OAAyB2V,OAcpBiB,GARAC,OACT,mBAAAnF,EAAA9J,UAAAjI,OAAIgW,EAAJ1M,MAAAyI,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAIgE,EAAJhE,GAAA/J,UAAA+J,GAAA,OACA,kBACEvL,iBAAK8P,eAAQP,IAAb3V,OAAuB2V,MAKhBiB,KAAKF,GAAK,IAKVI,QAAMJ,GAAK,GAIlBK,EACF,SAACzZ,EAAO0Z,GAAR,OACA,mBAAA9H,EAAA+H,EAAArP,UAAAjI,OAAIgW,EAAJ1M,MAAAgO,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAIvB,EAAJuB,GAAAtP,UAAAsP,GAAA,OAAAC,EAAAjI,KACG5R,EAAQ4Y,eAAQP,IADnBwB,EAAAjI,EAAA,WAEYyH,gBAASK,GAAThX,OAA2B2V,KAFvCzG,IAKEkI,EAAgB,SAACvB,GAAD,OAClBkB,EAAQlB,GAAO,EAAAP,EAAA9K,MAAK/L,UAAE6G,MAAF,UAAkBuQ,GAAUpX,UAAErB,IAAF,UAAgByY,MA6DvDS,GA3DAe,WAUT/Z,MAAO8Z,EAAc,SAOrBE,eAAgB7Y,UAAEa,KAAKyW,EAAaqB,EAAc,YAOlDG,MAAO,kBACLC,aAAcZ,0BACda,aAAcX,4BAQhBY,MAAO,kBACLC,QAASf,0BACTgB,OAAQd,4BAQVM,gBAOAL,WAQST,YAAY,SAAAnH,GAAA,IAAAG,EAAAhB,EAAAa,EAAA,GAAE7R,EAAFgS,EAAA,UAAqBlS,IAAK,kBAAME,GAAO8I,IAAvCkJ,EAAA,kRClRvB,wDAAAlT,EAAA,IACAkR,EAAAlR,EAAA,GACA4B,EAAA5B,EAAA,GAOO,IAAMyb,cAAYpZ,UAAEO,MAAM,SAAC8Y,EAAOxP,GAAR,OAAgB,IAAIyP,OAAOD,GAAOE,KAAK1P,KAO3D2P,cAAY,SAACC,GAAD,OAAa,SAACC,GAAD,OAAUJ,OAAOI,EAAMD,KAShDE,GAFAC,cAAc,SAACH,GAAD,OAAazZ,UAAEa,KAAK2Y,EAAUC,GAAUL,IAEtDO,kBAAkB3Z,UAAEa,KAAKb,UAAE6Z,MAAO7Z,UAAEQ,KAAK,OAEzCsZ,kBAAgB9Z,UAAEa,KAC7Bb,UAAE6Z,MACF7Z,UAAE+D,IAAI,SAAClE,GAAD,cAAeA,EAAf,QACNG,UAAEQ,KAAK,IACP,SAACX,GAAD,WAAYA,EAAZ,OAGIka,EAAa/Z,UAAEO,MAAM,SAACyZ,EAAYna,GAEtC,IAAMoa,EAASX,OAAOU,EAAWna,GAAI,MACrC,OAAO,SAACC,GAAD,SAAUA,IAAKA,EAAEoa,MAAMD,OA4CnBE,GApCAC,gBAAgBL,EAAWD,GAO3BO,eAAeN,EAAWJ,GAQ1BW,aAAata,UAAEO,MAAM,SAACga,EAAU1Q,GAK3C,IAJA,IAAI2Q,SACEnB,EAAQ,IAAIC,OAAOiB,EAAU,KAC7BhY,KAEiC,QAA/BiY,EAAUnB,EAAMoB,KAAK5Q,KAC3BtH,EAAO7B,MACLgZ,KAAMc,EAAQ,GACdE,MAAOF,EAAQ7Q,MACfgR,IAAKtB,EAAMuB,YAIf,OAAOrY,IAQI4X,WAAWna,UAAEO,MAAM,SAAC8Y,EAAOxP,GACtC,IAAIqQ,EAAQb,EAAMoB,KAAK5Q,GACnBtH,KACJ,GAAI8W,EAAM1V,MAAMZ,QAAQ,KAAO,GAAKmX,EAClC3X,EAAO7B,MAAMwZ,EAAMvQ,MAAOuQ,EAAMvQ,MAAQuQ,EAAM,GAAGhZ,cAEjD,KAAOgZ,GACL3X,EAAO7B,MAAMwZ,EAAMvQ,MAAO0P,EAAMuB,YAChCV,EAAQb,EAAMoB,KAAK5Q,GAGvB,OAAOtH,KAaIsY,qBAAmB7a,UAAEO,MAAM,SAACua,EAAQjR,GAAT,OACtC7J,UAAEsC,OACA,SAACC,EAAQwY,GAAT,OAAkB,EAAAlM,EAAAnO,MAAKyZ,EAASb,OAAOyB,EAAM,MAAOlR,GAAMtH,OAD5DvC,CAGEA,UAAE6Z,MAAMiB,MAGCE,0BAAwBhb,UAAEO,MAAM,SAACma,EAAOC,EAAKR,EAAUtQ,GAClE,IAAIoR,EAAS,EAOb,OANAjb,UAAEqI,KAAK,SAAC6S,GACNrR,GAAM,EAAAtK,EAAAwC,eAAcmZ,EAAQ,GAAKD,EAAQP,EAAO7Q,GAChDoR,GAAUP,EAAMxZ,OAChB2I,GAAM,EAAAtK,EAAAwC,eAAcmZ,EAAQ,GAAKD,EAAQN,EAAK9Q,GAC9CoR,GAAUN,EAAIzZ,SACb,EAAA2N,EAAAzM,aAAY+X,IACRtQ,IAWIsR,YAAYnb,UAAEO,MAAM,SAACma,EAAOC,EAAKS,EAASC,GAAtB,OAC/BL,EACEN,EACAC,EACA3a,UAAEsb,SAASF,GACPjB,EAASiB,EAASC,GAClBrb,UAAEmB,QAAQ0Z,EAAiBO,EAASC,IACxCA,0mCC1IJ1d,EAAA,IACAkR,EAAAlR,EAAA,GACAkZ,EAAAlZ,EAAA,GACA4N,EAAA5N,EAAA,GACA6B,EAAA7B,EAAA,GAYA4B,EAAA5B,EAAA,GACAyI,EAAAzI,EAAA,GACA2B,EAAA3B,EAAA,2HACA,IAAM+I,EAAQ1G,UAAEsG,SAAUK,KAAK,IAOlB4U,iBAAevb,UAAEO,MAAM,SAACuP,EAAKjR,GAAN,OAAA6Z,KAAoB5I,EAAMjR,KAOjD2c,kBAAgBxb,UAAEoY,KAAKmD,GAOvBE,gBAAc,SAAC5c,GAAD,OACzBmB,UAAEwD,QAAQ3E,GAASA,EAAQmB,UAAE+D,IAAI/D,UAAE0b,OAAOH,GAAevb,UAAE0P,QAAQ7Q,KAYxD8c,GALAC,gBAAgB5b,UAAE0I,OAAO1I,UAAEmM,UAK3BwP,gBAAgB3b,UAAEkF,aAKlB2W,qBAAmB7b,UAAE2K,OAAOgR,GAoE5BG,GA5DAC,oBAAoB/b,UAAE0I,OAAOmT,GAS7BG,WAAW,SAACjY,EAAKsT,GAAN,OAAiBrX,UAAEoI,WAAU,EAAA5I,EAAAuH,QAAOsQ,GAAStT,IAQxDkY,iBAAiBjc,UAAEO,MAAM,SAACqB,EAAMC,EAAIqa,GAAX,OACpClc,UAAE8G,IAAIlF,EAAMsa,GACRlc,UAAEa,KAAK,SAAChB,GAAD,OAAOG,UAAE2H,IAAI9F,EAAI7B,UAAErB,IAAIiD,EAAM/B,GAAIA,IAAIG,UAAE8H,MAAMlG,GAApD5B,CAA2Dkc,GAC3DA,IAWOC,mBAAmBnc,UAAEO,MAAM,SAACqB,EAAMC,EAAIqa,GAGjD,OAFIlc,UAAE8G,IAAIlF,EAAMsa,IACdlc,UAAEa,KAAK,SAAChB,GAAD,OAAO,EAAAL,EAAAkI,OAAM7F,EAAI7B,UAAErB,IAAIiD,EAAM/B,GAAIA,KAAI,EAAAL,EAAAoI,SAAQhG,GAApD5B,CAA2Dkc,GACtDA,IAWIE,cAAcpc,UAAEO,MAAM,SAAC8R,EAAM/I,GACxC,GAAItJ,UAAE8G,IAAIuL,EAAM/I,GAAM,CACpB,IAAIzK,EAAQmB,UAAErB,IAAI0T,EAAM/I,GAExB,OADA,EAAA9J,EAAAoI,SAAQyK,EAAM/I,GACPzK,KAWEid,SAAS9b,UAAEO,MAAM,SAAC8R,EAAMxS,GAAP,OAC5B,EAAAgX,EAAApL,QACEzL,UAAEwD,QACFxD,UAAE+D,IAAI,SAACjE,GAAD,OAAOE,UAAE2H,IAAI0K,EAAMvS,EAAGD,KAC5BG,UAAEqc,UACFrc,UAAErB,IAAI0T,EAAMxS,OAqBHyc,GAFAC,cAAcvc,UAAEO,MAAM,SAAC8R,EAAMtM,GAAP,OAAc/F,UAAEwc,QAAQV,EAAOzJ,GAAjBrS,CAAwB+F,KAE5DuW,gBAAe,EAAAzF,EAAArL,WAAUxL,UAAE8O,cAAe9O,UAAEwD,WAO5CiZ,kBAAgB,SAAhBA,EAAiBpB,EAAOqB,GAAR,OAC3B,EAAAld,EAAAyG,eACE,SAAC0W,EAAQ9d,EAAOiR,GAAhB,OACE9P,UAAEyH,MACAkV,GACCL,EAAazd,GAAS2c,EAAgBiB,GACrC5d,GACA,EAAAgQ,EAAAjO,aAAY8J,WAAZ,EAAuBgS,EAAO5M,UAIpCuL,IA4DOuB,GApDEC,kBAAkB,SAAChd,GAAD,OAAOG,UAAEsD,cAActD,UAAEwX,KAAK3X,GAAIG,UAAE6F,OAAOhG,KAK7Did,mBAAmB9c,UAAEO,MAChC,SAACwc,EAAWle,GAAZ,OACEmB,UAAEgd,SAASne,KAAWmB,UAAE4C,WAAW5C,UAAEwX,KAAK3Y,GAAQke,GAAW7b,SAMpD+b,cAAcjd,UAAEa,KAAK4a,EAAazb,UAAE+D,IAAI/D,UAAE6R,SAAU7R,UAAEiL,UAKtDiS,cAAcld,UAAEO,MAC3B,SAACiR,EAAM2L,EAAMte,GAAb,OAAuBmB,UAAErB,IAAI6S,EAAM2L,KAAUte,IASlCue,UAAUlV,UAAQC,UAC7B,UACA,SACA,WAHqBD,CAIrBxB,EAAMuB,QAKGoV,cAAcrd,UAAEO,MAAM,SAAC8R,EAAMxS,GAAP,OAAaG,UAAEsd,MAAMzd,EAAGwS,EAAMxS,KAKpD0d,QAAQvd,UAAEO,MAAM,SAAC8R,EAAMxS,GAAP,OAAaG,UAAEsd,MAAMjL,EAAMA,EAAMxS,KAKjD2d,UAAUxd,UAAEO,MAAM,SAACV,EAAGwS,GAAJ,OAAarS,UAAEsd,MAAMjL,EAAMA,EAAMxS,KAKnD+c,UAAU5c,UAAE6H,OAAO,EAAG,SAAC6U,EAAOpT,EAAKmU,GAAb,OAC/Bzd,UAAEa,MACA,EAAAtB,EAAA6J,WAAU,SAACvJ,GAAD,OAAOA,GAAKG,UAAEmF,SAAStF,EAAXG,CAAcsJ,KACpCtJ,UAAE0d,UAAUD,GAFdzd,CAGE0c,MAkBOiB,GAZAC,YAAY5d,UAAE6H,OAAO,EAAG,SAACyB,EAAKoT,EAAOe,GAAb,OACjCb,EAAQF,EAAOpT,EAAKmU,KAMXI,aAAa7d,UAAEO,MAAM,SAACmc,EAAOpT,GAAR,OAAgBtJ,UAAEuI,MAAK,EAAA/I,EAAAoH,OAAM0C,GAAMoT,KAKxDiB,iBAAiB3d,UAAEO,MAAM,SAACmc,EAAOpT,GAAR,OAAgBtJ,UAAEuI,MAAK,EAAA/I,EAAAqH,OAAMyC,GAAMoT,MAgB5DoB,GAXAC,cAAc/d,UAAEO,MAAM,SAACmc,EAAOpT,GAAR,OAC/BtJ,UAAErB,IAAIgf,EAAejB,EAAOpT,GAAMA,KAUzBwU,UAAU9d,UAAEO,MAAM,SAACyd,EAAS1U,GAAV,OAC3B,EAAA9J,EAAA2D,YAAW,SAAC9B,EAAKyO,GAAN,OAAc9P,UAAEqH,OAAOhG,EAATqX,KAAiBsF,GAAWlO,EAAMA,KAA3D,CAAmExG,MAQ1D2U,eAAa,SAACC,EAAUC,GACjC,IAAI7f,EAAIme,EAAcyB,GACtB,OAAOle,UAAEa,KACP4b,GACA,EAAAjd,EAAAqJ,kBAAiB,SAAChH,EAAIuV,GAAL,OAAkBxV,KAAMtD,EAAE8Y,GAAQvV,QACnD7B,UAAE4I,OAAO,SAAC/I,GAAD,OAAOG,UAAEkF,QAAQrF,EAAE+B,KAAM/B,EAAEgC,MAH/B7B,CAILme,IAgBOC,GARAC,kBAAkBre,UAAEa,KAAKod,EAAYH,EAAQ,UAQ7CM,OAAO,SAACF,EAAUC,GAC3B,IAAI7f,EAAIme,EAAcyB,GAClB/f,EAAIse,EAAc0B,GACtB,OAAOne,UAAEa,MACP,EAAArB,EAAAqJ,kBAAiB,SAAC7I,EAAGoX,GAAJ,OAAiBxV,KAAMtD,EAAE8Y,GAAQvV,GAAI1D,EAAEiZ,MACxDpX,UAAE4I,OAAO,SAAC/I,GAAD,OAAOG,UAAEkF,QAAQrF,EAAE+B,KAAM/B,EAAEgC,MAF/B7B,CAGLA,UAAEyH,MAAMnJ,EAAGH,MAwBXmgB,GAfOC,YAAYve,UAAEa,KAAKud,EAAMN,EAAQ,UAKjCU,SAAS,eAAC9B,EAADvT,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,MAAaG,EAAbH,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,aAClBnJ,UAAEa,KACAb,UAAEwX,KACFxX,UAAE+D,IAAI,SAAC+L,GACA9P,UAAEwF,SAASsK,EAAK4M,WACZpT,EAAIwG,KAJjB9P,CAOEsJ,IAEc,SAACmV,EAAUC,GAAX,OAChB1e,UAAEwD,QAAQib,GAAYA,EAASld,OAAOmd,QAAYlV,IAKzCmV,mBAAiB3e,UAAE4e,aAAaN,GAwDhCO,GAjDAC,gBAAgB9e,UAAEa,MAC3B,EAAArB,EAAA2D,YAAW,SAAC7B,EAAKwO,GAAN,OAAc,EAAAjB,EAAAzL,mBAAkB9B,EAAK,kBAAOwO,OACvD6O,GAQWI,WAAW/e,UAAEO,MAAM,SAACuP,EAAKjQ,GAAN,OAC9B,EAAAL,EAAAqJ,kBAAiB,SAACxH,EAAK2B,GAAN,OAAAgc,KAAkB3d,EAAlBqX,KAAwB5I,EAAM9M,KAAMnD,KAM5Cof,UAAU,SAACpf,GAAD,OAAOG,UAAE4I,OAAO5I,UAAE4K,MAAO/K,IAKnCqf,WAAW,SAACrf,GAAD,OAAOG,UAAE4I,OAAO5I,UAAEmf,OAAQtf,IAKrCuf,YAAY,SAACvf,GAAD,OAAOG,UAAE4I,OAAOiC,UAAShL,IAKrCwf,YAAY,SAACxf,GAAD,OAAOG,UAAE4I,OAAO5I,UAAEC,QAASJ,IAQvCyf,eAAetf,UAAE6H,OAAO,EAAG,SAACsG,GAAD,QAAA7D,EAAAnB,UAAAjI,OAASrB,EAAT2K,MAAAF,EAAA,EAAAA,EAAA,KAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAS5K,EAAT4K,EAAA,GAAAtB,UAAAsB,GAAA,OACpCzK,UAAEa,KAAKb,UAAEkN,KAAKiB,GAAMnO,UAAEuf,UAAtBvW,WAAAQ,EAAmC3J,KAQ1Bgf,mBAAmB7e,UAAE6H,OAAO,EAAG,SAAC2X,EAAYrR,GAAb,QAAAlC,EAAA9C,UAAAjI,OAAqBrB,EAArB2K,MAAAyB,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAqBrM,EAArBqM,EAAA,GAAA/C,UAAA+C,GAAA,OACxClM,UAAEa,KAAKb,UAAEkN,KAAKiB,GAAMnO,UAAE4e,aAAaY,IAAnCxW,WAAAQ,EAAmD3J,MAe1C4f,GAPAC,qBAAqBb,EAAiBP,GAOtCmB,UAAUzf,UAAEO,MAAM,SAACif,EAAYhO,EAAMxS,GAAnB,OAC3BwgB,EAAWxf,UAAErB,IAAI6S,EAAMxS,OAQd2gB,iBAAe3f,UAAEO,MAAM,SAAC8S,EAAW/J,GAAZ,OAAA0V,KAC7B1V,EACA+J,EAAU/J,MAkBXsW,GAVOC,iBAAiB7f,UAAEO,MAAM,SAACuP,EAAKlQ,EAAI0J,GAAV,OAClCqW,EAAaF,EAAQ7f,EAAIkQ,GAAzB6P,CAA+BrW,KAQtBwW,aAAa9f,UAAE6H,OAAO,GAAG,EAAAvI,EAAAmP,SAAQzO,UAAEwX,KAAMxX,UAAE+f,eACjC/f,UAAEggB,QAAQ1Z,SAAUK,KAAK,KA0BnCsZ,GAnBAC,iBAAiBlgB,UAAEO,MAAM,SAACV,EAAGC,GAAJ,OAClC8f,EAAe,SAACve,EAAKyO,GAAN,OAAc9P,UAAE8G,IAAIgJ,EAAKjQ,IAAIC,KAQnCqgB,iBAAiBngB,UAAEO,MAAM,SAACiR,EAAM4O,EAASphB,GAAhB,OAClCgB,UAAE8G,IAAI0K,EAAMxS,GAAUgB,UAAEiI,OAAOuJ,EAAM4O,EAASphB,GAAUA,IAS/CihB,mBAAmBjgB,UAAEO,MAAM,SAACiR,EAAM4O,EAASphB,GAAhB,OACpCgB,UAAE8G,IAAI0K,EAAMxS,IAAU,EAAAQ,EAAAwI,UAASwJ,EAAM4O,EAASphB,GAAUA,KAGtDqhB,EAAcrgB,UAAEO,MAAM,SAAC6f,EAASE,EAAY9Q,GAAtB,OACxBxP,UAAEa,KACA4b,GACA,EAAAjd,EAAAgJ,aAAY,SAAC6K,EAAW7B,GAAZ,OACV4O,EAAQ5O,EAAMxR,UAAEmF,SAASkO,GAAY7D,KAEvC,kBAAMA,GALRxP,CAMEsgB,KAeOC,kBAAgBF,EAAYJ,GAc5BO,qBAAmBH,EAAYrY,YAiDtCyY,GAnCOC,iBAAiB1gB,UAAEO,MAAM,SAAC+f,EAAY9Q,GAAb,OAClCgR,EAAiBF,EAAYtgB,UAAEqQ,UAAUb,MAehCmR,cAAc3gB,UAAEO,MAAM,SAAC+f,EAAY9Q,GAAb,OAC/B+Q,EAAcD,EAAYtgB,UAAEqQ,UAAUb,MAkBvBxP,UAAEO,MAAM,SAACqgB,EAAUC,EAAU7hB,GAArB,OACvBgB,UAAEa,MACA,EAAArB,EAAAqJ,kBAAiB,SAAChK,EAAOiR,GAAR,OAXD,SAAClQ,EAAIf,GAAL,OAClBmB,UAAEuD,WAAW3D,GAAMA,EAAGf,GAASmB,UAAEkF,QAAQtF,EAAIf,GAUViiB,CAAcjiB,EAAOmB,UAAErB,IAAImR,EAAK9Q,MACjEgB,UAAE6F,OACF+a,EAHF5gB,CAIE6gB,MAUOE,YAAYN,EAAWzgB,UAAE2X,MAAM,SAAC9X,GAAD,OAAOA,KAStCmhB,gBAAgBP,EAAWzgB,UAAEihB,KAAK,SAACphB,GAAD,OAAOA,qRC/jBpD,IAAAN,EAAA5B,EAAA,uDACAA,EAAA,IACAkZ,EAAAlZ,EAAA,GACAkR,EAAAlR,EAAA,GACAujB,EAAAvjB,EAAA,GACA4N,EAAA5N,EAAA,GAEA,IAAIwjB,GAAc,EAAAtK,EAAA9K,MAAKlB,UAAS,IASnBuW,SAAOphB,UAAEO,MAAM,SAAC2O,EAAKC,EAAMkS,GAAZ,OAC1B,EAAA9V,EAAAV,SAAQwW,GACJF,EAAYE,GACZF,EAAYjS,GAAOmS,EAAUF,EAAYhS,KAwBpCmS,GAtBEC,QAAQH,EAAK,IAAK,KAOlBI,SAASJ,EAAK,IAAK,KACnBK,gBAAgBzhB,UAAEa,KAAKb,UAAES,QAAST,UAAE+D,IAAI/D,UAAEsW,MAAOtW,UAAEQ,KAAK,MAMxDkhB,eAAc,EAAAniB,EAAAwE,MAAI,EAAA8S,EAAA9K,MAAK/L,UAAE0F,SAAU1F,UAAEsW,OAQvCgL,YAAYthB,UAAE2hB,WAOdC,oBAAkB,SAAC9e,GAAD,OAC3BjE,OAAO,EAAAgY,EAAA9K,MAAK/L,UAAE6hB,YAAa/e,EAApB,CAAuBA,EAAEjE,OAChCijB,MAAOhf,EAAEgf,OAASR,GAAU,EAAAzK,EAAA9K,MAAK/L,UAAE6hB,YAAa/e,EAApB,CAAuBA,EAAEjE,UAgB5CkjB,GARAC,mBAAmBhiB,UAAE+D,IAAI6d,GAQzBG,iBAAiB/hB,UAAEO,MAAM,SAAC0D,EAAWge,EAAexd,GAA3B,OAClCzE,UAAEa,MACA,EAAAgW,EAAA9K,MAAK/L,UAAE0F,SAAU,SAAC7F,GAAD,OAAQA,MACzB,EAAAgP,EAAApJ,cACE,EAAAyb,EAAAxK,eACE,kBAAMzS,GACN,kBAAMge,KAGVjiB,UAAEQ,KAAK,IARTR,CASEyE,MAwBOyd,GAfAC,aAAaJ,EAAe,KAAM,SAelCG,mBAAmBliB,UAAEO,MAAM,SAAC6hB,EAAUC,GAC/C,IAAI7d,EAAI,SAAC3E,GAEP,IADA,IAAI0C,EAAS1C,EACNyiB,EAAM/f,IACXA,EAAS1C,EAAIyiB,EAAMziB,GACnByiB,EAAMziB,IAAM,EAGd,OADAyiB,EAAM/f,IAAW+f,EAAM/f,IAAW,GAAK,EAChCA,GAEL+f,EAAQF,EAASC,GAMrB,OALA7d,EAAE8d,MAAQA,EACV9d,EAAE+d,MAAQ,WAER/d,EAAE8d,MADFA,MAGK9d,KAcEge,eAAe,eAAClhB,EAAD6H,UAAAjI,OAAA,QAAAsI,IAAAL,UAAA,GAAAA,UAAA,aACxB+Y,EAAiBliB,UAAEyiB,QAAQziB,UAAEmM,UAAW7K,IAS/BohB,mBAAmB,SAAC7iB,GAAD,OAC5BG,UAAE0F,SAAS7F,GAAKG,UAAEsW,KAAKtW,UAAE2iB,QAAQ,OAAQ,IAAK9iB,IAAMA,oIC/ItD,wDAAAlC,EAAA,IACAmL,EAAAnL,EAAA,GAOO,IAAIilB,iBACTlV,QAAQmV,OACP,SAAChjB,GAAD,OACC6N,QAAQ0F,IAAIpT,UAAE6F,OAAOhG,IAAImQ,KAAK,SAACnK,GAAD,OAAY7F,UAAEkD,UAAUlD,UAAEwX,KAAK3X,GAAIgG,MAKjEid,EAAY,SAACjkB,EAAO2F,GAAR,OAAe3F,EAAMmR,KAAOnR,EAAMmR,KAAKxL,GAAKA,EAAE3F,IAa1DkkB,EACF,SAAC/kB,GAAD,OACA,SAACglB,GAAD,QAAA1Y,EAAAnB,UAAAjI,OAASiN,EAAT3D,MAAAF,EAAA,EAAAA,EAAA,KAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAS0D,EAAT1D,EAAA,GAAAtB,UAAAsB,GAAA,OACA,mBAAAwB,EAAA9C,UAAAjI,OAAIrB,EAAJ2K,MAAAyB,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAIrM,EAAJqM,GAAA/C,UAAA+C,GAAA,SACE3K,OAAI4M,GAAK,SAACtO,GAAD,OAAOA,KAAGyC,OAAOtE,EAAMglB,eAAOnjB,OAYhCojB,YAAYF,EA5BA,SAAC1Q,EAAM7N,GAC5B,GAAIxE,UAAEihB,KAAK,OAAQ5O,GAAO,CACxB,GAAIrS,UAAEwD,QAAQ6O,GAAO,OAAO3E,QAAQ0F,IAAIf,GAAMrC,KAAKxL,GACnD,GAAIxE,UAAE8O,cAAcuD,GAAO,OAAOuQ,EAAavQ,GAAMrC,KAAKxL,GAE5D,OAAOse,EAAUzQ,EAAM7N,KA+Bd0e,gBAAgBH,EA7BP,SAAC1Q,EAAM7N,GAEzB,OADA6N,GAAO,EAAAvJ,EAAAiK,gBAAA,CAAgBV,GAChByQ,EAAUzQ,EAAM7N,8fCxBzBjG,OAAAiZ,KAAA2L,GAAAC,QAAA,SAAAtT,GAAA,YAAAA,GAAA,eAAAA,GAAAvR,OAAAC,eAAArB,EAAA2S,GAAApR,YAAA,EAAAC,IAAA,kBAAAwkB,EAAArT,mBACAvR,OAAAiZ,KAAAhY,GAAA4jB,QAAA,SAAAtT,GAAA,YAAAA,GAAA,eAAAA,GAAAvR,OAAAC,eAAArB,EAAA2S,GAAApR,YAAA,EAAAC,IAAA,kBAAAa,EAAAsQ,mBACAvR,OAAAiZ,KAAAjY,GAAA6jB,QAAA,SAAAtT,GAAA,YAAAA,GAAA,eAAAA,GAAAvR,OAAAC,eAAArB,EAAA2S,GAAApR,YAAA,EAAAC,IAAA,kBAAAY,EAAAuQ,mBACAvR,OAAAiZ,KAAAlY,GAAA8jB,QAAA,SAAAtT,GAAA,YAAAA,GAAA,eAAAA,GAAAvR,OAAAC,eAAArB,EAAA2S,GAAApR,YAAA,EAAAC,IAAA,kBAAAW,EAAAwQ,oBACAvR,OAAAiZ,KAAA6L,GAAAD,QAAA,SAAAtT,GAAA,YAAAA,GAAA,eAAAA,GAAAvR,OAAAC,eAAArB,EAAA2S,GAAApR,YAAA,EAAAC,IAAA,kBAAA0kB,EAAAvT,oBACAvR,OAAAiZ,KAAA8L,GAAAF,QAAA,SAAAtT,GAAA,YAAAA,GAAA,eAAAA,GAAAvR,OAAAC,eAAArB,EAAA2S,GAAApR,YAAA,EAAAC,IAAA,kBAAA2kB,EAAAxT,mBACAvR,OAAAiZ,KAAApR,GAAAgd,QAAA,SAAAtT,GAAA,YAAAA,GAAA,eAAAA,GAAAvR,OAAAC,eAAArB,EAAA2S,GAAApR,YAAA,EAAAC,IAAA,kBAAAyH,EAAA0J,mBACAvR,OAAAiZ,KAAA3I,GAAAuU,QAAA,SAAAtT,GAAA,YAAAA,GAAA,eAAAA,GAAAvR,OAAAC,eAAArB,EAAA2S,GAAApR,YAAA,EAAAC,IAAA,kBAAAkQ,EAAAiB,mBACAvR,OAAAiZ,KAAAX,GAAAuM,QAAA,SAAAtT,GAAA,YAAAA,GAAA,eAAAA,GAAAvR,OAAAC,eAAArB,EAAA2S,GAAApR,YAAA,EAAAC,IAAA,kBAAAkY,EAAA/G,oBACAvR,OAAAiZ,KAAA+L,GAAAH,QAAA,SAAAtT,GAAA,YAAAA,GAAA,eAAAA,GAAAvR,OAAAC,eAAArB,EAAA2S,GAAApR,YAAA,EAAAC,IAAA,kBAAA4kB,EAAAzT,mBACAvR,OAAAiZ,KAAAjM,GAAA6X,QAAA,SAAAtT,GAAA,YAAAA,GAAA,eAAAA,GAAAvR,OAAAC,eAAArB,EAAA2S,GAAApR,YAAA,EAAAC,IAAA,kBAAA4M,EAAAuE,oBACAvR,OAAAiZ,KAAAgM,GAAAJ,QAAA,SAAAtT,GAAA,YAAAA,GAAA,eAAAA,GAAAvR,OAAAC,eAAArB,EAAA2S,GAAApR,YAAA,EAAAC,IAAA,kBAAA6kB,EAAA1T,mBACAvR,OAAAiZ,KAAA1O,GAAAsa,QAAA,SAAAtT,GAAA,YAAAA,GAAA,eAAAA,GAAAvR,OAAAC,eAAArB,EAAA2S,GAAApR,YAAA,EAAAC,IAAA,kBAAAmK,EAAAgH,mBACAvR,OAAAiZ,KAAA0J,GAAAkC,QAAA,SAAAtT,GAAA,YAAAA,GAAA,eAAAA,GAAAvR,OAAAC,eAAArB,EAAA2S,GAAApR,YAAA,EAAAC,IAAA,kBAAAuiB,EAAApR,QAfA,wDAAAnS,EAAA,IAiBY8lB,OACAC,OACA9Z,OACAhK,OACAkb,OACA9b,OACA4U,OACAnP,OACAkf,OACAtK,OACAuK,OACA1M,OACA7L,OACAwY,gKAWL,IAAMC,mBAAiB9jB,UAAE+jB,GAAG,GAWtBC,cAAY,SAAC1a,GAAD,QACrBA,IACc,iBAAf,IAAOA,EAAP,YAAA2a,EAAO3a,KAAmC,mBAARA,IACf,mBAAbA,EAAI0G,MAKAkU,YAAUC,wBAIlBV,EACAC,EACA9Z,EACAhK,EACAkb,EACA9b,EACA4U,EACAnP,EACAkf,EACAtK,EACAuK,EACA1M,EACA7L,EACAwY,GACHC,iBACAE,YACAE","file":"futil-js.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"lodash/fp\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"lodash/fp\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"futil-js\"] = factory(require(\"lodash/fp\"));\n\telse\n\t\troot[\"futil-js\"] = factory(root[\"lodash/fp\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 15);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import _ from 'lodash/fp'\nimport { callOrReturn } from './function'\nimport { insertAtIndex } from './collection'\nimport { reduceIndexed, mapIndexed } from './conversion'\n\n// TODO: Move to proper files and expose\nlet callUnless = (check) => (failFn) => (fn) => (x, y) =>\n  check(x) ? failFn(y) : check(y) ? failFn(x) : fn(x, y)\nlet callUnlessEmpty = callUnless(_.isEmpty)\nlet wrapArray = (x) => [x]\nlet callUnlessEmptyArray = callUnlessEmpty(wrapArray)\nlet dropRight = _.dropRight(1)\nlet last = _.takeRight(1)\n\n/**\n * Joins an array after compacting. Note that due to the underlying behavior of `_.curry` no default `join` value is supported -- you must pass in some string with which to perform the join.\n *\n * @signature joinString -> [string1, string2, ...stringN] -> string1 + joinString + string2 + joinString ... + stringN\n * @typescript {(join: string, x: any[]) => string}\n */\nexport let compactJoin = _.curry((join, x) => _.compact(x).join(join))\n\n/**\n * Compacts and joins an array with `.`\n *\n * @signature [string1, string2, ...stringN] -> string1 + '.' + string2 + '.' ... + stringN\n * @typescript {(arr: any[]) => string}\n */\nexport let dotJoin = compactJoin('.')\n\n/**\n * Compacts an array by the provided function, then joins it with `.`\n *\n * @signature filterFunction -> [string1, string2, ...stringN] -> string1 + '.' + string2 + '.' ... + stringN\n */\nexport let dotJoinWith = (fn) => (x) => _.flow(_.filter(fn), _.join('.'))(x)\n\n/**\n * Returns an array of elements that are repeated in the array.\n *\n * @signature [a] -> [a]\n */\nexport let repeated = _.flow(\n  _.groupBy((e) => e),\n  _.filter((e) => e.length > 1),\n  _.flatten,\n  _.uniq\n)\n\n/**\n * Return `array` with `val` pushed.\n *\n * @signature (val, array) -> array\n */\nexport let push = _.curry((val, arr) => arr.concat([val]))\nexport let pushIn = _.curry((arr, val) => arr.concat([val]))\nexport let pushOn = _.curry((arr, val) => {\n  arr.push(val)\n  return arr\n})\n\n/**\n * Moves a value from one index to another\n *\n * @signature (from, to, array) -> array\n */\nexport let moveIndex = _.curry((from, to, arr) =>\n  _.flow(_.pullAt(from), insertAtIndex(to, arr[from]))(arr)\n)\n\nlet overlaps = (x, y) => y[0] > x[1]\nlet mergeRange = (x, y) => [[x[0], _.max(x.concat(y))]]\nlet actuallMergeRanges = callUnlessEmptyArray((x, y) =>\n  overlaps(x, y) ? [x, y] : mergeRange(x, y)\n)\n\n/**\n * Takes any number of ranges and return the result of merging them all.\n *\n * @signature ([[], [], []]) -> [[], []]\n * @example [[0,7], [3,9], [11,15]] -> [[0,9], [11,15]]\n */\nexport let mergeRanges = _.flow(\n  _.sortBy([0, 1]),\n  _.reduce(\n    (result, range) =>\n      dropRight(result).concat(\n        actuallMergeRanges(_.flatten(last(result)), range)\n      ),\n    []\n  )\n)\n\n/**\n * Determines if an array is a subset of another array.\n *\n * @signature ([a], [a]) -> boolean\n */\nexport let isSubset = _.curry(\n  (array1, array2) => _.difference(array1, array2).length === 0\n)\n\n/**\n * Creates a function that takes an element of the original array as argument and returns the next element in the array (with wrapping). Note that (1) This will return the first element of the array for any argument not in the array and (2) due to the behavior of `_.curry` the created function will return a function equivalent to itself if called with no argument.\n *\n * @signature [a, b...] -> a -> b\n */\nexport let cycle = _.curry((a, n) => a[(a.indexOf(n) + 1) % a.length])\n\n/**\n * Creates an object from an array by generating a key/value pair for each element in the array using the key and value mapper functions.\n *\n * @signature (k, v, [a]) -> { k(a): v(a) }\n */\nexport let arrayToObject = _.curry((k, v, a) =>\n  _.zipObject(mapIndexed(k, a), mapIndexed(v, a))\n)\n\n/**\n * Converts and array of keys to an object using a predicate\n *\n * @signature (v, [a]) => { a: v(a) }\n * @typescript <T>(fn: (k: string) => T, keys: string[]): { [K in typeof keys[number]]: T } // TS not enforcing the keys :(\n */\nexport let keysToObject = arrayToObject((x) => x)\n\n/**\n * A version of `_.zipObjectDeep` that supports passing a function to determine values intead of an array, which will be invoked for each key.\n *\n */\nexport let zipObjectDeepWith = _.curry((x, y) =>\n  _.zipObjectDeep(x, _.isFunction(y) && _.isArray(x) ? _.times(y, x.length) : y)\n)\n\n/**\n * Converts an array of strings into an object mapping to true. Useful for optimizing `includes`.\n *\n * @signature [a, b] -> {a:true, b:true}\n */\nexport let flags = zipObjectDeepWith(_, () => true)\n\n/**\n * Returns a list of all prefixes. Works on strings, too. Implementations must guarantee that the orginal argument has a length property.\n *\n * @signature ['a', 'b', 'c'] -> [['a'], ['a', 'b'], ['a', 'b', 'c']]\n */\nexport let prefixes = (list) =>\n  _.range(1, _.size(list) + 1).map((x) => _.take(x, list))\n\n/**\n * Creates an object with encode and decode functions for encoding arrays as strings. The input string is used as input for join/split.\n *\n * @signature string -> {encode: array -> string, decode: string -> array}\n */\nexport let encoder = (separator) => ({\n  encode: compactJoin(separator),\n  decode: _.split(separator),\n})\n\n/**\n * An encoder using `.` as the separator\n *\n * @signature { encode: ['a', 'b'] -> 'a.b', decode: 'a.b' -> ['a', 'b'] }\n */\nexport let dotEncoder = encoder('.')\n\n/**\n * An encoder using `/` as the separator\n *\n * @signature { encode: ['a', 'b'] -> 'a/b', decode: 'a/b' -> ['a', 'b'] }\n */\nexport let slashEncoder = encoder('/')\n\n/**\n * Takes a predicate function and an array, and returns an array of arrays where each element has one or more elements of the original array. Similar to Haskell's [groupBy](http://zvon.org/other/haskell/Outputlist/groupBy_f.html).\n\nThe predicate is called with two arguments: the current group, and the current element. If it returns truthy, the element is appended to the current group; otherwise, it's used as the first element in a new group.\n * \n * @signature (([a], a) -> Boolean) -> [a] -> [[a]]\n */\nexport let chunkBy = _.curry((f, array) =>\n  _.isEmpty(array)\n    ? []\n    : _.reduce(\n        (acc, x) =>\n          f(_.last(acc), x)\n            ? [..._.initial(acc), [..._.last(acc), x]]\n            : [...acc, [x]],\n        [[_.head(array)]],\n        _.tail(array)\n      )\n)\n\n/**\n * `chunkBy` when the returned value of an iteratee changes\n *\n * @signature f -> [] -> [[], ...]\n * @since 1.75.0\n */\nexport let chunkByValue = _.curry((f, array) =>\n  chunkBy(\n    (group, fn) => _.isEqual(_.iteratee(f)(_.last(group)), _.iteratee(f)(fn)),\n    array\n  )\n)\n\n/**\n * Just like toggleElement, but takes an iteratee to determine if it should remove or add. This is useful for example in situations where you might have a checkbox that you want to represent membership of a value in a set instead of an implicit toggle. Used by includeLens.\n *\n * @signature bool -> value -> list -> newList\n */\nexport let toggleElementBy = _.curry((check, val, arr) =>\n  (callOrReturn(check, val, arr) ? _.pull : push)(val, arr)\n)\n\n/**\n * Removes an element from an array if it's included in the array, or pushes it in if it doesn't. Immutable (so it's a clone of the array).\n *\n * @signature (any, array) -> array\n */\nexport let toggleElement = toggleElementBy(_.includes)\n\n/**\n * Puts the result of calling `f` in between each element of the array. `f` is a standard lodash iterator taking the value, index, and list. If `f` is not a function, it will treat `f` as the value to intersperse. See https://ramdajs.com/docs/#intersperse.\n *\n * @signature f -> array -> [array[0], f(), array[n], ....)\n * @note This works great with the `differentLast` iterator. Also, `intersperse` can be used with JSX components!\n * @example // Example with words (toSentence is basically this flowed into a `_.join('')`):\n * F.intersperse(\n *   differentLast(\n *     () => 'or',\n *     () => 'or perhaps'\n *   ),\n *   ['first', 'second', 'third']\n * )\n * // ['first', 'or', 'second', 'or perhaps', 'third']\n *\n * // Example with React and JSX:\n * let results = [1, 2, 3]\n * return (\n *   <div>\n *     <b>Results:</b>\n *     <br />\n *     {_.flow(\n *       _.map((x) => <b>{x}</b>),\n *       F.intersperse(\n *         F.differentLast(\n *           () => ', ',\n *           () => ' and '\n *         )\n *       )\n *     )(results)}\n *   </div>\n * )\n * // Output:\n * // **Results:**\n * // **1**, **2** and **3**.\n */\nexport let intersperse = _.curry((f, arr) => {\n  // Handle nonsense\n  if (_.isEmpty(arr) || _.isString(arr)) return []\n  // Use `_.values` to support objects\n  let [x0, ...xs] = _.values(arr)\n  return reduceIndexed(\n    (acc, x, i) =>\n      i === xs.length ? [...acc, x] : [...acc, callOrReturn(f, acc, i, xs), x],\n    [x0],\n    xs\n  )\n})\n\n/**\n * Replaces an element in an array with `value` based on the boolean result of a function `fn`.\n *\n * @signature (fn(array_element), value, array) -> array\n */\nexport let replaceElementBy = _.curry((f, b, arr) =>\n  _.map((c) => (f(c) ? b : c), arr)\n)\n\n/**\n * Replaces all elements equal to `target` in an array with `value`.\n *\n * @signature (target, value, array) -> array\n */\nexport let replaceElement = _.curry((a, b, arr) =>\n  replaceElementBy(_.isEqual(a), b, arr)\n)\n","import _ from 'lodash/fp'\nimport { aspects } from './aspect'\n\nconst noRearg = _.convert({ rearg: false })\nconst mutable = _.convert({ immutable: false })\nconst noCap = _.convert({ cap: false })\n\n// Flips\n// ----------\n/**\n * lodash/fp is great, but sometimes the curry order isn't exactly what you want.\n *\n * These methods provide alternative orderings that are sometimes more convenient.\n *\n * The idea of `In` methods is to name them by convention, so when ever you need a method that actually takes the collection first (e.g. a `get` where the data is static but the field is dynamic), you can just add `In` to the end (such as `getIn` which takes the object first)\n * @module convert(_In)\n */\n\n/**\n * Just like `_.get`, but with `{rearg: false}` so the argument order is unchanged from non fp lodash.\n *\n * @tags convert(_In)\n */\nexport const getIn = noRearg.get\n\n/**\n * Just like `_.has`, but with `{rearg: false}` so the argument order is unchanged from non fp lodash.\n *\n * @tags convert(_In)\n */\nexport const hasIn = noRearg.has\n\n/**\n * Just like `_.pick`, but with `{rearg: false}` so the argument order is unchanged from non fp lodash.\n *\n * @tags convert(_In)\n */\nexport const pickIn = noRearg.pick\n\n/**\n * Just like `_.includes`, but with `{rearg: false}` so the argument order is unchanged from non fp lodash.\n *\n * @tags convert(_In)\n */\nexport const includesIn = noRearg.includes\nexport const inversions = _.mapKeys((k) => `${k}In`, noRearg)\n\n// Mutables\n// ----------\n/**\n * lodash/fp likes to keep things pure, but sometimes JS can get pretty dirty.\n *\n * These methods are alternatives for working with data that--for whatever the use case is--needs to be mutable\n *\n * Any methods that interact with mutable data will use the `On` convention (as it is some action occuring `On` some data)\n * @module convert(_On)\n */\n\n/**\n * Just like `_.extend`, but with `{mutable: true}` so it mutates.\n *\n * @tags convert(_On)\n */\nexport const extendOn = mutable.extend\n\n/**\n * Just like `_.defaults`, but with `{mutable: true}` so it mutates.\n *\n * @tags convert(_On)\n */\nexport const defaultsOn = mutable.defaults\n\n/**\n * Just like `_.merge`, but with `{mutable: true}` so it mutates.\n *\n * @tags convert(_On)\n */\nexport const mergeOn = mutable.merge\n\n/**\n * Just like `_.set`, but with `{mutable: true}` so it mutates.\n *\n * @tags convert(_On)\n */\nexport const setOn = mutable.set\n// Curry required until https://github.com/lodash/lodash/issues/3440 is resolved\n\n/**\n * Just like `_.unset`, but with `{mutable: true}` so it mutates.\n *\n * @tags convert(_On)\n */\nexport const unsetOn = _.curryN(2, mutable.unset)\n\n/**\n * Just like `_.pull`, but with `{mutable: true}` so it mutates.\n *\n * @tags convert(_On)\n */\nexport const pullOn = mutable.pull\n\n/**\n * Just like `_.update`, but with `{mutable: true}` so it mutates.\n *\n * @tags convert(_On)\n */\nexport const updateOn = mutable.update\n\n// Uncaps\n// ------\n/**\n * lodash/fp caps iteratees to one argument by default, but sometimes you need the index.\n *\n * These methods are uncapped versions of lodash's methods.\n *\n * Any method with uncapped iteratee arguments will use the `Indexed` convention.\n * @module convert(_Indexed)\n */\n\n// Un-prefixed Deprecated\nexport const reduce = aspects.deprecate(\n  'reduce',\n  '1.28.0',\n  'reduceIndexed'\n)(noCap.reduce)\nexport const mapValues = aspects.deprecate(\n  'mapValues',\n  '1.28.0',\n  'mapValuesIndexed'\n)(noCap.mapValues)\nexport const each = aspects.deprecate(\n  'each',\n  '1.28.0',\n  'eachIndexed'\n)(noCap.each)\n\n/**\n * Just like `_.map`, but with `{cap: false}` so iteratees are not capped (e.g. indexes are passed).\n *\n * @tags convert(_Indexed)\n */\nexport const mapIndexed = noCap.map\n\n/**\n * Just like `_.find`, but with `{cap: false}` so iteratees are not capped (e.g. indexes are passed).\n *\n * @tags convert(_Indexed)\n */\nexport const findIndexed = noCap.find\n\n/**\n * Just like `_.each`, but with `{cap: false}` so iteratees are not capped (e.g. indexes are passed).\n *\n * @tags convert(_Indexed)\n */\nexport const eachIndexed = noCap.each\n\n/**\n * Just like `_.reduce`, but with `{cap: false}` so iteratees are not capped (e.g. indexes are passed).\n *\n * @tags convert(_Indexed)\n */\nexport const reduceIndexed = noCap.reduce\n\n/**\n * Just like `_.pickBy`, but with `{cap: false}` so iteratees are not capped (e.g. indexes are passed).\n *\n * @tags convert(_Indexed)\n */\nexport const pickByIndexed = noCap.pickBy\n\n/**\n * Just like `_.omitBy`, but with `{cap: false}` so iteratees are not capped (e.g. indexes are passed).\n *\n * @tags convert(_Indexed)\n */\nexport const omitByIndexed = noCap.omitBy\n\n/**\n * Just like `_.mapValues`, but with `{cap: false}` so iteratees are not capped (e.g. indexes are passed).\n *\n * @tags convert(_Indexed)\n */\nexport const mapValuesIndexed = noCap.mapValues\n","import _ from 'lodash/fp'\nimport { isTraversable } from './tree'\n\n/**\n * Maps a flow of `f1, f2, ...fn` over a collection.\n *\n * @signature [f1, f2, ...fn] -> _.map(_.flow(fn))\n */\nexport const flowMap = (...fns) => _.map(_.flow(...fns))\n\n/**\n * A version of `find` that also applies the predicate function to the result. Useful when you have an existing function that you want to apply to a member of a collection that you can best find by applying the same function.\n *\n * @signature f -> x -> f(find(f, x))\n */\nexport let findApply = _.curry((f, arr) => _.iteratee(f)(_.find(f, arr)))\n\n/**\n * Maps a function over an iterable. Works by default for Arrays and Plain Objects.\n *\n * @signature (a -> b) -> [a] -> [b]\n */\nexport let map = _.curry((f, x) =>\n  (_.isArray(x) ? _.map : _.mapValues).convert({ cap: false })(f, x)\n)\n\n/**\n * Maps a function over a recursive iterable. Works by default for nested Arrays, nested Plain Objects and mixed nested Arrays and Plain Objects. Also works for any other iterable data type as long as two other values are sent: a mapping function, and a type checker (See the unit tests for deepMap).\n *\n * @signature (a -> b) -> [a] -> [b]\n */\nexport let deepMap = _.curry((fn, obj, _map = map, is = isTraversable) =>\n  _map((e) => (is(e) ? deepMap(fn, fn(e), _map, is) : e), obj)\n)\n\nlet insertAtStringIndex = (index, val, str) =>\n  str.slice(0, index) + val + str.slice(index)\nlet insertAtArrayIndex = (index, val, arr) => {\n  let result = _.clone(arr)\n  result.splice(index, 0, val)\n  return result\n}\n\n/**\n * Inserts value into an array or string at `index`\n *\n * @signature (index, val, array|string) -> array|string\n * @example (1, '123', 'hi') -> 'h123i'\n */\nexport let insertAtIndex = _.curry((index, val, collection) =>\n  _.isString(collection)\n    ? insertAtStringIndex(index, val, collection)\n    : insertAtArrayIndex(index, val, collection)\n)\n\n/**\n * Maps `fn` over the input collection and compacts the result.\n *\n * @signature (fn, collection) -> collection\n */\nexport let compactMap = _.curry((fn, collection) =>\n  _.flow(_.map(fn), _.compact)(collection)\n)\n\n/**\n * Returns the size of a collection after filtering by `fn`.\n *\n * @signature (fn, collection) -> number\n */\nexport const sizeBy = _.curry((fn, collection) =>\n  _.flow(_.filter(fn), _.size)(collection)\n)\n","/**\n * Language level utilities\n * @module lang\n */\n\nimport _ from 'lodash/fp'\nimport { tree } from './tree'\n\n/**\n * Just throws whatever it is passed.\n */\nexport let throws = (x) => {\n  throw x\n}\n\n/**\n * Tap error will run the provided function and then throw the first argument. It's like `_.tap` for rethrowing errors.\n */\nexport let tapError =\n  (f) =>\n  (e, ...args) => {\n    f(e, ...args)\n    throw e\n  }\nexport let isNotNil = _.negate(_.isNil)\n\n/**\n * Negated `_.isNil`\n *\n * @aliases isNotNil\n */\nexport let exists = isNotNil\n\n/**\n * Returns true if the input has a `length` property > 1, such as arrays, strings, or custom objects with a lenth property\n *\n * @signature (Array<T> | string | {length}) -> bool\n */\nexport let isMultiple = (x) => (x || []).length > 1\n\n/**\n * A curried, flipped `_.add`. The flipping matters for strings, e.g. `F.append('a')('b') -> 'ba'`\n *\n * @signature (a, b) => b + a\n */\nexport let append = _.curry((x, y) => y + x)\n\n// True for everything except null, undefined, '', [], and {}\n\n/**\n * Designed to determine if something has a meaningful value, like a ux version of truthiness. It's false for everything except null, undefined, '', [], and {}. Another way of describing it is that it's the same as falsiness except 0 and false are truthy and {} is falsey. Useful for implementing \"required\" validation rules.\n *\n * @signature x -> bool\n */\nexport let isBlank = _.overSome([\n  _.isNil,\n  _.isEqual(''),\n  _.isEqual([]),\n  _.isEqual({}),\n])\n\n/**\n * Opposite of `isBlank`\n *\n * @signature x -> bool\n */\nexport let isNotBlank = _.negate(isBlank)\n\n/**\n * Recurses through an object's leaf properties and passes an array of booleans to the combinator, such as `_.some`, `_.every`, and `F.none`\n *\n * @signature f -> x -> bool\n */\nexport let isBlankDeep = (combinator) => (x) =>\n  combinator(isBlank, tree().leaves(x))\n","import _ from 'lodash/fp'\nimport { callOrReturn } from './function'\nimport { exists } from './lang'\n\n/**\n * Creates a function that checks if none of the array of predicates passed in returns truthy for `x`\n *\n * @signature ([f1, f2, ...fn]) -> !f1(x) && !f2(x) && ...!fn(x)\n */\nexport const overNone = _.flow(_.overSome, _.negate)\n\nlet boolIteratee = (x) =>\n  _.isBoolean(x) || _.isNil(x) ? () => x : _.iteratee(x)\n\n/**\n * http://ramdajs.com/docs/#ifElse. The transform function T supports passing a boolean for `condition` as well as any valid argument of `_.iteratee`, e.g. `myBool = applyTest(x); F.ifElse(myBool, doSomething, doSomethingElse);`\n *\n * @signature (condition, onTrue, onFalse, ...x) -> (T(condition)(...x) ? onTrue(...x) : onFalse(...x))\n */\nexport let ifElse = _.curryN(4, (condition, onTrue, onFalse, ...x) =>\n  boolIteratee(condition)(...x)\n    ? callOrReturn(onTrue, ...x)\n    : callOrReturn(onFalse, ...x)\n)\n\n/**\n * http://ramdajs.com/docs/#when. `T` extends `_.iteratee` as above.\n *\n * @signature (condition, onTrue, ...x) -> (T(condition)(...x) ? onTrue(...x) : _.identity(...x))\n */\nexport let when = _.curryN(3, (condition, t, ...x) =>\n  ifElse(condition, t, _.identity, ...x)\n)\n\n/**\n * http://ramdajs.com/docs/#unless. `T` extends `_.iteratee` as above.\n *\n * @signature (condition, onFalse, ...x) -> (T(condition)(...x) ? _.identity(...x) : onFalse(...x))\n */\nexport let unless = _.curryN(3, (condition, f, ...x) =>\n  ifElse(condition, _.identity, f, ...x)\n)\n\n/**\n * `when` curried with `Boolean`\n */\nexport let whenTruthy = when(Boolean)\n\n/**\n * `when` curried with `exists`\n */\nexport let whenExists = when(exists)\n\n/**\n * `unless` curried with `Boolean`\n */\nexport let unlessTruthy = unless(Boolean)\n","import _ from 'lodash/fp'\n\n/**\n * If `fn` is a function, call the function with the passed-in arguments. Otherwise, return `false`.\n *\n * @signature (fn, a, b) -> fn(a, b)\n */\nexport let maybeCall = (fn, ...args) => _.isFunction(fn) && fn(...args)\n\n/**\n * If `fn` is a function, call the function with the passed-in arguments. Otherwise, return `fn`.\n *\n * @signature (fn, a, b) -> fn(a, b)\n */\nexport let callOrReturn = (fn, ...args) => (_.isFunction(fn) ? fn(...args) : fn)\n\n/**\n * Binds a function of an object to it's object.\n *\n * @signature (a, Monoid f) -> f[a] :: f a\n */\nexport let boundMethod = (method, object) => object[method].bind(object)\n\n/**\n * http://ramdajs.com/docs/#converge. Note that `f` is called on the array of the return values of `[g1, g2, ...gn]` rather than applied to it.\n *\n * @signature (f, [g1, g2, ...gn]) -> a -> f([g1(a), g2(a), ...])\n */\nexport let converge =\n  (converger, branches) =>\n  (...args) =>\n    converger(_.over(branches)(...args))\n\nexport let composeApply = (f, g) => (x) => f(g(x))(x)\n\n/**\n * A combinator that combines compose and apply. `f` should be a 2 place curried function. Useful for applying comparisons to pairs defined by some one place function, e.g. `var isShorterThanFather = F.comply(isTallerThan, fatherOf)`\n *\n * @signature (f, g) -> x -> f(g(x))(x)\n * @aliases composeApply\n */\nexport let comply = composeApply\n\n/**\n * Implement `defer`, ported from bluebird docs and used by debounceAsync\n */\nexport let defer = () => {\n  let resolve\n  let reject\n  let promise = new Promise((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n  return {\n    resolve,\n    reject,\n    promise,\n  }\n}\n\n/**\n * A `_.debounce` for async functions that ensure the returned promise is resolved with the result of the execution of the actual call. Using `_.debounce` with `await` or `.then` would result in the earlier calls never returning because they're not executed - the unit tests demonstate it failing with `_.debounce`.\n */\nexport let debounceAsync = (n, f) => {\n  let deferred = defer()\n  let debounced = _.debounce(n, (...args) => {\n    deferred.resolve(f(...args))\n    deferred = defer()\n  })\n  return (...args) => {\n    debounced(...args)\n    return deferred.promise\n  }\n}\n\nlet currier =\n  (f) =>\n  (...fns) =>\n    _.curryN(fns[0].length, f(...fns))\n/**\n * Flurry is combo of flow + curry, preserving the arity of the initial function. See https://github.com/lodash/lodash/issues/3612.\n *\n * @signature (f1, f2, ...fn) -> f1Arg1 -> f1Arg2 -> ...f1ArgN -> fn(f2(f1))\n */\nexport let flurry = currier(_.flow)\n\n/**\n * Uncurry allows curried functions to be called with all its arguments at once. Methods curried with lodash or ramda support this call style out of the box, but hand curried methods. This can happen as the result of function composition.\n *\n * @signature (arg -> arg -> arg) -> (arg, arg, arg)\n */\nexport let uncurry =\n  (fn) =>\n  (...args) =>\n    args.reduce((fn, arg) => fn(arg), fn)\n\n/**\n * Resets curry arity. Useful in scenarios where you have a curried function whose arity isn't detectable by a lodash or ramda curry - such as one constructed via function composition.\n *\n * @signature (n, fn) -> fn(arg1, ...argN)\n */\nexport let recurry = (n, fn) => _.curryN(n, uncurry(fn))\n\n/**\n * Returns a function that applies the mapping operation to all of the arguments of a function. Very similar to _.overArgs, but runs a single mapper on all of the args args.\n *\n * @signature (mapper, fn) -> (...args) -> fn(...args.map(mapper))\n */\nexport let mapArgs = _.curry(\n  (mapper, fn) =>\n    (...x) =>\n      fn(...x.map(mapper))\n)\n","/**\n * All tree functions take a traversal function so that you can customize how to traverse arbitrary nested structures.\n *\n * _Note_: Be careful about cyclic structures that can result in infinite loops, such as objects with references to itself. There are cases where you'd intentionally want to visit the same node multiple times, such as traversing a directed acyclic graph (which would work just fine and eventually terminate, but would visit a node once for each parent it has connected to it) - but it's up to the user to be sure you don't create infinite loops.\n * @module tree\n */\n\nimport _ from 'lodash/fp'\nimport { findIndexed } from './conversion'\nimport { push, dotEncoder, slashEncoder } from './array'\n\n/**\n * A default check if something can be traversed - currently it is arrays and plain objects.\n *\n * @signature node -> bool\n */\nexport let isTraversable = (x) => _.isArray(x) || _.isPlainObject(x)\n\n/**\n * The default traversal function used in other tree methods if you don't supply one. It returns false if it's not traversable or empty, and returns the object if it is.\n *\n * @signature node -> [...childNodes]\n */\nexport let traverse = (x) => isTraversable(x) && !_.isEmpty(x) && x\n\n/**\n * A depth first search which visits every node returned by `traverse` recursively. Both `pre-order` and `post-order` traversals are supported (and can be mixed freely). `walk` also supports exiting iteration early by returning a truthy value from either the `pre` or `post` functions. The returned value is also the return value of `walk`. The pre, post, and traversal functions are passed the current node as well as the parent stack (where parents[0] is the direct parent).\n *\n * @signature traverse -> (pre, post=_.noop) -> tree -> x\n */\nexport let walk =\n  (next = traverse) =>\n  (pre, post = _.noop, parents = [], parentIndexes = []) =>\n  (tree, index) =>\n    pre(tree, index, parents, parentIndexes) ||\n    findIndexed(\n      walk(next)(pre, post, [tree, ...parents], [index, ...parentIndexes]),\n      next(tree, index, parents, parentIndexes) || []\n    ) ||\n    post(tree, index, parents, parentIndexes)\n\n// async/await is so much cleaner but causes regeneratorRuntime shenanigans\n// export let findIndexedAsync = async (f, data) => {\n//   for (let key in data) {\n//     if (await f(data[key], key, data)) return data[key]\n//   }\n// }\n// The general idea here is to keep popping off key/value pairs until we hit something that matches\nexport let findIndexedAsync = (f, data, remaining = _.toPairs(data)) => {\n  if (!remaining.length) return\n  let [[key, val], ...rest] = remaining\n  return Promise.resolve(f(val, key, data)).then((result) =>\n    result ? val : rest.length ? findIndexedAsync(f, data, rest) : undefined\n  )\n}\n\n/**\n * A version of `walk` which supports async traversals.\n *\n * @signature traverse -> (pre, post=_.noop) -> async tree -> x\n */\nexport let walkAsync =\n  (next = traverse) =>\n  (pre, post = _.noop, parents = [], parentIndexes = []) =>\n  (tree, index) =>\n    Promise.resolve(pre(tree, index, parents, parentIndexes))\n      .then(\n        (preResult) =>\n          preResult ||\n          findIndexedAsync(\n            walkAsync(next)(\n              pre,\n              post,\n              [tree, ...parents],\n              [index, ...parentIndexes]\n            ),\n            next(tree, index, parents, parentIndexes) || []\n          )\n      )\n      .then(\n        (stepResult) => stepResult || post(tree, index, parents, parentIndexes)\n      )\n\n/**\n * Structure preserving pre-order depth first traversal which clones, mutates, and then returns a tree. Basically `walk` with a `_.cloneDeep` first (similar to a tree map because it preserves structure). `_iteratee` can be any suitable argument to `_.iteratee` https://lodash.com/docs/4.17.5#iteratee\n *\n * @signature traverse -> _iteratee -> tree -> newTree\n */\nexport let transformTree = (next = traverse) =>\n  _.curry((f, x) => {\n    let result = _.cloneDeep(x)\n    walk(next)(f)(result)\n    return result\n  })\n\n/**\n * Just like `_.reduce`, but traverses over the tree with the traversal function in `pre-order`.\n *\n * @signature traverse -> (accumulator, initialValue, tree) -> x\n */\nexport let reduceTree = (next = traverse) =>\n  _.curry((f, result, tree) => {\n    walk(next)((...x) => {\n      result = f(result, ...x)\n    })(tree)\n    return result\n  })\n\n/**\n * Default `writeNode` for `mapTree`. It writes the node to the parent at the given index.\n * Using the traversal function with tree iteratee properties to find children.\n */\nexport let writeTreeNode =\n  (next = traverse) =>\n  (node, index, [parent, ...parents], [parentIndex, ...indexes]) => {\n    next(parent, parentIndex, parents, indexes)[index] = node\n  }\n\n/**\n * Structure preserving tree map! `writeNode` informs how to write a single node, but the default will generally work for most cases. The iteratee is passed the standard `node, index, parents, parentIndexes` args and is expected to return a transformed node.\n *\n * @signature (traverse, writeNode) -> f -> tree -> newTree\n */\nexport let mapTree = (next = traverse, writeNode = writeTreeNode(next)) =>\n  _.curry(\n    (mapper, tree) =>\n      transformTree(next)((node, i, parents, ...args) => {\n        if (parents.length)\n          writeNode(mapper(node, i, parents, ...args), i, parents, ...args)\n      })(mapper(tree)) // run mapper on root, and skip root in traversal\n  )\n\n/**\n * Like `mapTree`, but only operates on lead nodes. It is a convenience method for `mapTree(next, writeNode)(F.unless(next, mapper), tree)`\n *\n * @signature (traverse, writeNode) -> f -> tree -> newTree\n */\nexport let mapTreeLeaves = (next = traverse, writeNode = writeTreeNode(next)) =>\n  _.curry((mapper, tree) =>\n    // this unless wrapping can be done in user land, this is pure convenience\n    // mapTree(next, writeNode)(F.unless(next, mapper), tree)\n    mapTree(next, writeNode)((node) => (next(node) ? node : mapper(node)), tree)\n  )\n\n/**\n * Like `treeToArray`, but accepts a customizer to process the tree nodes before putting them in an array. The customizer is passed the standard `node, index, parents, parentIndexes` args and is expected to return a transformed node. It's `_.map` for trees - but it's not called treeMap because it does not preserve the structure as you might expect `map` to do. See `mapTree` for that behavior.\n *\n * @signature traverse -> f -> tree -> [f(treeNode), f(treeNode), ...]\n */\nexport let treeToArrayBy = (next = traverse) =>\n  _.curry((fn, tree) =>\n    reduceTree(next)((r, ...args) => push(fn(...args), r), [], tree)\n  )\n\n/**\n * Flattens the tree nodes into an array, simply recording the node values in pre-order traversal.\n *\n * @signature traverse -> tree -> [treeNode, treeNode, ...]\n */\nexport let treeToArray = (next = traverse) => treeToArrayBy(next)((x) => x)\n\n// This could reuse treeToArrayBy and just reject traversable elements after, but this is more efficient\n// We can potentially unify these with tree transducers\n\n/**\n * Like `leaves`, but accepts a customizer to process the leaves before putting them in an array.\n *\n * @signature traverse -> f -> tree -> [f(treeNode), f(treeNode), ...]\n */\nexport let leavesBy = (next = traverse) =>\n  _.curry((fn, tree) =>\n    reduceTree(next)(\n      (r, node, ...args) => (next(node) ? r : push(fn(node, ...args), r)),\n      [],\n      tree\n    )\n  )\n\n/**\n * Returns an array of the tree nodes that can't be traversed into in `pre-order`.\n *\n * @signature traverse -> tree -> [treeNodes]\n */\nexport let leaves = (next = traverse) => leavesBy(next)((x) => x)\n\n/**\n * Looks up a node matching a path, which defaults to lodash `iteratee` but can be customized with buildIteratee. The `_iteratee` members of the array can be any suitable arguments for `_.iteratee` https://lodash.com/docs/4.17.5#iteratee\n *\n * @signature (traverse, buildIteratee) -> ([_iteratee], tree) -> treeNode\n */\nexport let treeLookup = (next = traverse, buildIteratee = _.identity) =>\n  _.curry((path, tree) =>\n    _.reduce(\n      (tree, path) => findIndexed(buildIteratee(path), next(tree)),\n      tree,\n      path\n    )\n  )\n\n/**\n * Similar to a keyBy (aka groupBy) for trees, but also transforms the grouped values (instead of filtering out tree nodes). The transformer takes three args, the current node, a boolean of if the node matches the current group, and what group is being evaluated for this iteratee. The transformer is called on each node for each grouping. `_iteratee` is any suitable argument to `_.iteratee`, as above.\n *\n * @signature traverse -> transformer -> _iteratee -> tree -> result\n */\nexport let keyTreeByWith = (next = traverse) =>\n  _.curry((transformer, groupIteratee, x) =>\n    _.flow(\n      treeToArrayBy(next)(_.iteratee(groupIteratee)),\n      _.uniq,\n      _.keyBy(_.identity),\n      _.mapValues((group) =>\n        transformTree(next)((node) => {\n          let matches = _.iteratee(groupIteratee)(node) === group\n          transformer(node, matches, group)\n        }, x)\n      )\n    )(x)\n  )\n\n// Flat Tree\n\n/**\n * A utility tree iteratee that returns the stack of node indexes\n *\n * @signature (x, i, xs, is) => [i, ...is]\n */\nexport let treeKeys = (x, i, xs, is) => [i, ...is]\n\n/**\n * A utility tree iteratee that returns the stack of node values\n *\n * @signature (x, i, xs) => [x, ...xs]\n */\nexport let treeValues = (x, i, xs) => [x, ...xs]\n\n/**\n * Creates a path builder for use in `flattenTree`. By default, the builder will look use child indexes and a dotEncoder. Encoder can be an encoding function or a futil `encoder` (an object with encode and decode functions)\n *\n * @signature (build, encoder) -> treePathBuilderFunction\n */\nexport let treePath =\n  (build = treeKeys, encoder = dotEncoder) =>\n  (...args) =>\n    (encoder.encode || encoder)(build(...args).reverse())\n\n/**\n * Creates a path builder for use in `flattenTree`, using a slashEncoder and using the specified prop function as an iteratee on each node to determine the keys.\n *\n * @signature prop -> treePathBuilderFunction\n */\nexport let propTreePath = (prop) =>\n  treePath(_.flow(treeValues, _.map(prop)), slashEncoder)\n\n/**\n * Creates a flat object with a property for each node, using `buildPath` to determine the keys. `buildPath` takes the same arguments as a tree walking iteratee. It will default to a dot tree path.\n *\n * @signature traverse -> buildPath -> tree -> result\n */\nexport let flattenTree =\n  (next = traverse) =>\n  (buildPath = treePath()) =>\n    reduceTree(next)(\n      (result, node, ...x) => _.set([buildPath(node, ...x)], node, result),\n      {}\n    )\n\nexport let flatLeaves = (next = traverse) => _.reject(next)\n\nconst treeFind = (next, getResult) => (it, tree) => {\n  let result\n  walk(next)((node, ...args) => {\n    if (_.iteratee(it)(node, ...args)) {\n      result = getResult([node, ...args])\n      return result\n    }\n  })(tree)\n  return result\n}\n\n/**\n * Finds the first node matching the iteratee in pre-order traversal. The\n * iteratee can be any suitable argument to `_.iteratee`\n * https://lodash.com/docs/4.17.5#iteratee\n *\n * @signature (traverse) -> (iteratee, tree) -> treeNode\n */\nexport const findNode = (next = traverse) => treeFind(next, ([node]) => node)\n\n/**\n * Resolves all Promise nodes of a tree and replaces them with the result of calling `.then`\n * Exposed on `F.tree` as `resolveOn`\n * _CAUTION_ This method mutates the tree passed in. This is generally safe and more performant (and can be intuited from the `On` convention in the name), but it's worth calling out.\n *\n * @signature (traverse, writeNode) -> tree -> result\n */\nexport let resolveOnTree =\n  (next = traverse, writeNode = writeTreeNode(next)) =>\n  (tree) => {\n    let promises = []\n    walk(next)((node, ...args) => {\n      if (node.then)\n        // Mutates because `_.deepClone` on a tree of promises causes explosions\n        promises.push(node.then((newNode) => writeNode(newNode, ...args)))\n    })(tree)\n    // Dont return a promise if nothing was async\n    return _.isEmpty(promises) ? tree : Promise.all(promises).then(() => tree)\n  }\n\n/**\n * Takes a traversal function and returns an object with all of the tree methods pre-applied with the traversal. This is useful if you want to use a few of the tree methods with a custom traversal and can provides a slightly nicer api.\nExposes provided `traverse` function as `traverse`\n * \n * @signature (traverse, buildIteratee, writeNode) -> { walk, walkAsync, transform, reduce, toArrayBy, toArray, leaves, leavesBy, lookup, keyByWith, traverse, flatten, flatLeaves, map, mapLeaves, resolveOn }\n */\nexport let tree = (\n  next = traverse,\n  buildIteratee = _.identity,\n  writeNode = writeTreeNode(next)\n) => ({\n  walk: walk(next),\n  walkAsync: walkAsync(next),\n  transform: transformTree(next),\n  reduce: reduceTree(next),\n  toArrayBy: treeToArrayBy(next),\n  toArray: treeToArray(next),\n  leaves: leaves(next),\n  leavesBy: leavesBy(next),\n  lookup: treeLookup(next, buildIteratee),\n  keyByWith: keyTreeByWith(next),\n  traverse: next,\n  flatten: flattenTree(next),\n  flatLeaves: flatLeaves(next),\n  map: mapTree(next, writeNode),\n  mapLeaves: mapTreeLeaves(next, writeNode),\n  resolveOn: resolveOnTree(next, writeNode),\n  findNode: findNode(next),\n})\n","/**\n * Aspects provide a functional oriented implementation of Aspect Oriented Programming.\n * An aspect wraps a function and allows you run code at various points like before and after execution.\n * Notably, aspects in this library allow you to have a shared state object between aspects and are very useful for automating things like status indicators, etc on functions.\n *\n * There is a _lot_ of prior art in the javascript world, but most of it assumes a vaguely object oriented context.\n * The implementation in `futil-js` is done in just 20 lines of code and seems to capture all of the use cases of AOP.\n *\n * **Note**: To do OO style AOP with this these aspects, just use lodash's `_.update` method and optionally `boundMethod` from `futil` if `this` matters\n *\n * **Caveat**: While you can and should compose (or `_.flow`) aspects together, don't put non aspects in the middle of the composition. Aspects rely on a `.state` property on the wrapped function that they propagate through, but the chain will break if a non-aspect is mixed in between. Additionally, if you need external access to the state, make sure the aspects are the outer most part of the composition so the `.state` property will be available on the result of the composition.\n *\n * There are a few basic aspects included on `F.aspects` (E.g. `var loggedFunc = F.aspect(F.aspects.logs)(func)`) because they seem to be universally useful.\n * All of the provided aspects take an `extend` function to allow customizing the state mutation method (e.g. in mobx, you'd use `extendObservable`).\n * If null, they default to `defaultsOn` from `futil-js` - check the unit tests for example usage.\n * @module aspect\n */\n\nimport _ from 'lodash/fp'\nimport { defaultsOn, setOn } from './conversion'\nimport { throws, tapError } from './lang'\n\n/**\n * The aspect api takes an options object and returns a function which takes a function to wrap.\nThe wrapped function will be decorated with a `state` object and is equivalent to the original function for all arguments.\n\nOptions supports the following parameters:\n\n| Name | Description |\n| --- | --- |\n| `init: (state) -> ()` | A function for setting any inital state requirements. Should mutate the shared state object. |\n| `after: (result, state, params) -> ()` | Runs after the wrapped function executes and recieves the shared state and the result of the function. Can be async. |\n| `before: (params, state) -> ()` | Runs before the wrapped function executes and receves the shared state and the params passed to the wrapped function. Can be async. |\n| `onError: (error, state, params) -> ()` | Runs if the wrapped function throws an error. If you don't throw inside this, it will swallow any errors that happen. |\n| `always: (state, params) -> ()` | Runs after the wrapped function whether it throws an error or not, similar to a `Promise.catch` |\n * \n * @signature {options} -> f -> aspectWrapped(f)\n * @example let exampleAspect = aspect({\n *   before: () => console.log('pre run'),\n *   after: () => console.log('post run'),\n * })\n * let f = () => console.log('run')\n * let wrapped = exampleAspect(f)\n * wrapped()\n * // Logs to the console:\n * // pre run\n * // run\n * // post run\n * @tags aspect\n */\nexport let aspect =\n  ({\n    name = 'aspect',\n    init = _.noop,\n    after = _.noop,\n    before = _.noop,\n    always = _.noop,\n    onError = throws,\n    // ?: interceptParams, interceptResult, wrap\n  }) =>\n  (f) => {\n    let { state = {} } = f\n    init(state)\n    // Trick to set function.name of anonymous function\n    let x = {\n      [name](...args) {\n        let result\n        let error\n        return Promise.resolve()\n          .then(() => before(args, state))\n          .then(() => f(...args))\n          .then((r) => {\n            result = r\n          })\n          .then(() => after(result, state, args))\n          .catch((e) => onError(e, state, args))\n          .catch((e) => {\n            error = e\n          })\n          .then(() => always(state, args))\n          .then(() => {\n            if (error) throw error\n          })\n          .then(() => result)\n      },\n    }\n    x[name].state = state\n    return x[name]\n  }\n\n/**\n * This is a synchronous version of `aspect`, for situations when it's not desirable to `await` a method you're adding aspects to. The API is the same, but things like `onError` won't work if you pass an async function to the aspect.\n *\n * @tags aspect\n */\nexport let aspectSync =\n  ({\n    name = 'aspect',\n    init = _.noop,\n    after = _.noop,\n    before = _.noop,\n    always = _.noop,\n    onError = throws,\n    // ?: interceptParams, interceptResult, wrap\n  }) =>\n  (f) => {\n    let { state = {} } = f\n    init(state)\n    // Trick to set function.name of anonymous function\n    let x = {\n      [name](...args) {\n        try {\n          before(args, state)\n          let result = f(...args)\n          after(result, state, args)\n          return result\n        } catch (e) {\n          onError(e, state, args)\n          throw e\n        } finally {\n          always(state, args)\n        }\n      },\n    }\n    x[name].state = state\n    return x[name]\n  }\n\n// Example Aspects\nlet logs = (extend = defaultsOn) =>\n  aspect({\n    init: extend({ logs: [] }),\n    after: (result, state) => state.logs.push(result),\n    name: 'logs',\n  })\nlet error = (extend = defaultsOn) =>\n  aspect({\n    init: extend({ error: null }),\n    onError: setOn('error'),\n    name: 'error',\n  })\nlet errors = (extend = defaultsOn) =>\n  aspect({\n    init: extend({ errors: [] }),\n    onError: (e, state) => state.errors.push(e),\n    name: 'errors',\n  })\nlet status = (extend = defaultsOn) =>\n  aspect({\n    init: extend({\n      status: null,\n      processing: false,\n      succeeded: false,\n      failed: false,\n      // Computed get/set properties don't work, probably because lodash extend methods don't support copying them\n      setStatus(x) {\n        this.status = x\n        this.failed = x === 'failed'\n        this.succeeded = x === 'succeeded'\n        this.processing = x === 'processing'\n      },\n    }),\n    before(params, state) {\n      state.setStatus('processing')\n    },\n    after(result, state) {\n      state.setStatus('succeeded')\n    },\n    onError: tapError((e, state) => {\n      state.setStatus('failed')\n    }),\n    name: 'status',\n  })\nlet clearStatus = (timeout = 500) =>\n  aspect({\n    always(state) {\n      if (timeout !== null) {\n        setTimeout(() => {\n          state.setStatus(null)\n        }, timeout)\n      }\n    },\n    name: 'clearStatus',\n  })\n// This is a function just for consistency\nlet concurrency = () =>\n  aspect({\n    before(params, state) {\n      if (state.processing) {\n        throw Error('Concurrent Runs Not Allowed')\n      }\n    },\n    name: 'concurrency',\n  })\n\nlet command = (extend, timeout) =>\n  _.flow(\n    status(extend),\n    clearStatus(timeout),\n    concurrency(extend),\n    error(extend)\n  )\n\nlet deprecate = (subject, version, alternative) =>\n  aspectSync({\n    before: () =>\n      console.warn(\n        `\\`${subject}\\` is deprecated${version ? ` as of ${version}` : ''}${\n          alternative ? ` in favor of \\`${alternative}\\`` : ''\n        } ${_.trim((Error().stack || '').split('\\n')[3])}`\n      ),\n    init(state) {\n      state.isDeprecated = true\n      state.subject = subject\n      state.version = version\n      state.alternative = alternative\n    },\n  })\n\nexport let aspects = {\n  /**\n   * Logs adds a `logs` array to the function state and just pushes in results on each run\n   *\n   * @tags aspect\n   */\n  logs,\n\n  /**\n   * Captures any exceptions thrown and set it on an `error` error it puts on state\n   *\n   * @tags aspect\n   */\n  error,\n\n  /**\n   * Captures any exceptions thrown and pushes them sequentially into an `errors` array it puts on state\n   *\n   * @tags aspect\n   */\n  errors,\n\n  /**\n   * Adds a `status` property that is set to `processing` before the wrapped function runs and `succeeded` when it's done or `failed` if it threw an exception. Also adds shortcuts on state for `processing`, `succeeded`, and `failed`, which are booleans which are based on the value of `status`. Also adds a `setStatus` method which is used internally to update these properties.\n   *\n   * @tags aspect\n   */\n  status,\n\n  /**\n   * Utility for marking functions as deprecated - it's just a `before` with a console.warn. Takes the name of thing being deprecated, optionally deprecation version, and optionally an alternative and returns a higher order function which you can wrap deprecated methods in. This is what's used internally to mark deprecations. Includes a partial stack trace as part of the deprecation warning.\n   *\n   * @tags aspect\n   */\n  deprecate,\n\n  /**\n   * Sets `status` to null after provided timeout (default is 500ms) elapses. If a null timeout is passed, it will never set status to null.\n   *\n   * @tags aspect\n   */\n  clearStatus,\n\n  /**\n   * Prevents a function from running if it's state has `processing` set to true at the time of invocation\n   *\n   * @tags aspect\n   */\n  concurrency,\n\n  /**\n   * Flows together `status`, `clearStatus`, `concurrency`, and `error`, taking `extend` and `timeout` as optional parameters to construct the aspect\n   *\n   * @tags aspect\n   */\n  command,\n}\n","import _ from 'lodash/fp'\n\n/**\n * Creates an iterator that handles the last item differently for use in any function that passes `(value, index, list)` (e.g. `mapIndexed`, `eachIndexed`, etc). Both the two handlers and the result are iterator functions that take `(value, index, list)`.\n *\n * @signature handleItem -> handleLastItem -> iterator\n */\nexport let differentLast = (normalCase, lastCase) => (acc, i, list) =>\n  i === list.length - 1\n    ? _.iteratee(lastCase)(acc, i, list)\n    : _.iteratee(normalCase)(acc, i, list)\n","/**\n * A lens is a getter and setter pair. You use them to write code that needs to read _and_ write a value (like a method to flip a boolean switch, or a React component that reads and writes some state) without worrying about the implementation.\n *\n * Functions that operate on lenses can handle a few different \"shorthand\" structures. This is similar to lodash's `_.iteratee` (which allows their methods to treat strings, objects, or functions as shorthand predicates)\n *\n * A lens can be any of these formats:\n *\n * `({ get, set })`\n * An object with a `get` function and `set` function.\n * Found in: MobX \"boxed observables\"\n * Example Usage: `F.flip({ get, set })`\n *\n * `([value, setter])`\n * An array of the `value` and a `setter` function to change it.\n * Found in: React's useState hook\n * Example Usage: `F.flip([value, setter])`\n *\n * `(lookup, object)`\n * A lookup path and object pair e.g. ('key', object). The lookup path is anything you can pass to `_.get` (so nested paths with `.` or as an array are supported)\n * Found in: MobX observable objects, native JS objects\n * Example Usage: `F.flip(lookup, object)`\n *\n * `(x => {})`\n * A function which returns the value when called with no arguments and sets it when called with one.\n * Found in: Knockout observables, jQuery plugin APIs\n * Example Usage: `F.flip(x => {})`\n *\n * `(getter, setter)`\n * A getter and setter pair.\n * Found in: Anywhere you have a getter and setter function\n * Example Usage: `F.flip(getter, setter)`\n *\n * > Note: Setter methods are generally mutable (unlike Ramda's lenses, for example).\n *\n * We've included a few example \"bindings\" on `F.domLens`. These take a lens and return an object that's useful in a DOM context (like React or raw JS). In React terms, they're methods that generate the props you'd use to do two way binding to a lens.\n * ![lens meme](http://giphygifs.s3.amazonaws.com/media/1jnyRP4DorCh2/giphy.gif)\n * @module lens\n */\n\nimport _ from 'lodash/fp'\nimport { setOn } from './conversion'\nimport { toggleElementBy } from './array'\nimport { when } from './logic'\n\n// Stubs\n\n/**\n * Takes a value and returns a function lens for that value. Mostly used for testing and mocking purposes.\n */\nexport let functionLens =\n  (val) =>\n  (...x) => {\n    if (!x.length) return val\n    val = x[0]\n  }\n\n/**\n * Takes a value and returns a object lens for that value. Mostly used for testing and mocking purposes.\n */\nexport let objectLens = (val) => ({\n  get: () => val,\n\n  /**\n   * Sets the value of the lens, regardless of its format\n   *\n   * @signature propertyValue -> Lens -> object.propertyName\n   */\n  set(x) {\n    val = x\n  },\n})\n\n// Lens Conversion\n\n/**\n * Converts a function lens an object lens. Mostly used for testing and mocking purposes.\n */\nexport let fnToObj = (fn) => ({\n  get: fn,\n  set: fn,\n})\n\n/**\n * Converts an object lens to a function lens. Mostly used for testing and mocking purposes.\n */\nexport let objToFn =\n  (lens) =>\n  (...values) =>\n    values.length ? lens.set(values[0]) : lens.get()\n\n// Lens Construction\n\n/**\n * Creates an object lens for a given property on an object. `.get` returns the value at that path and `set` places a new value at that path. Supports deep paths like lodash get/set.\nYou typically won't use this directly since it is supported implicitly.\n * \n * @signature propertyName -> object -> { get: () -> object.propertyName, set: propertyValue -> object.propertyName }\n */\nexport let lensProp = (field, source) => ({\n  get: () => _.get(field, source), //source[field],\n  set(value) {\n    setOn(field, value, source)\n    // source[field] = value\n  },\n})\n\n// NOTE: This used to use mapValues; however, doing so would sometimes cause issues\n// in some edge cases like trying to lens state coming from an inject function\n// in the mobx library. It would inadvertently cause the inject to re-run.\n// Using reduce here alleviates that issue.\n\n/**\n * Takes an object and returns an object with lenses at the values of each path. Basically `mapValues(lensProp)`. Typically you would use the implicit `(key, object)` format instead.\n */\nexport let lensOf = (object) =>\n  _.reduce(\n    (res, key) => {\n      res[key] = lensProp(key, object)\n      return res\n    },\n    {},\n    _.keys(object)\n  )\n\n/**\n * An include lens represents membership of a value in a set. It takes a value and lens and returns a new lens - kind of like a \"writeable computed\" from MobX or Knockout. The view and set functions allow you to read and write a boolean value for whether or not a value is in an array. If you change to true or false, it will set the underlying array lens with a new array either without the value or with it pushed at the end.\n *\n * @signature value -> arrayLens -> includeLens\n */\nexport let includeLens = (value, ...lens) => ({\n  get: () => _.includes(value, view(...lens)),\n  // Uniq is to ensure multiple calls to set(true) don't push multiple times since this is about membership of a set\n  set: (x) => set(_.uniq(toggleElementBy(!x, value, view(...lens))), ...lens),\n})\n\n// Lens Manipulation\n//let construct = (...lens) => (lens[1] ? lensProp(...lens) : lens[0])\nlet lensPair = (get, set) => ({ get, set })\nlet construct = (...args) =>\n  args[1]\n    ? _.every(_.isFunction, args)\n      ? lensPair(...args)\n      : lensProp(...args)\n    : when(_.isArray, stateLens)(args[0])\n\nlet read = (lens) => (lens.get ? lens.get() : lens())\n\n/**\n * Gets the value of the lens, regardless of its format\n *\n * @signature Lens -> object.propertyName\n */\nexport let view = (...lens) => read(construct(...lens))\n\n/**\n * Returns a function that gets the value of the lens, regardless of its format\n *\n * @signature Lens -> (() -> object.propertyName)\n */\nexport let views =\n  (...lens) =>\n  () =>\n    view(...lens)\nlet write = (val, lens) => (lens.set ? lens.set(val) : lens(val))\nexport let set = _.curryN(2, (val, ...lens) => write(val, construct(...lens)))\n\n/**\n * Creates a function that will set a lens with the provided value\n */\nexport let sets = _.curryN(\n  2,\n  (val, ...lens) =>\n    () =>\n      set(val, ...lens)\n)\n\n/**\n * Takes an iteratee and lens and creates a function that will set a lens with the result of calling the iteratee with the provided value\n */\nexport let setsWith = _.curry(\n  (f, ...lens) =>\n    (x) =>\n      set(_.iteratee(f)(x), ...lens)\n)\n\n/**\n * Takes a lens and negates its value\n */\nexport let flip =\n  (...lens) =>\n  () =>\n    set(!view(...lens), ...lens)\n\n/**\n * Returns a function that will set a lens to `true`\n */\nexport let on = sets(true)\n\n/**\n * Returns a function that will set a lens to `false`\n */\nexport let off = sets(false)\n\n// Lens Consumption\n// Map lens to dom event handlers\nlet binding =\n  (value, getEventValue) =>\n  (...lens) => ({\n    [value]: view(...lens),\n    onChange: setsWith(getEventValue, ...lens),\n  })\n// Dom events have relevent fields on the `target` property of event objects\nlet targetBinding = (field) =>\n  binding(field, when(_.hasIn(`target.${field}`), _.get(`target.${field}`)))\n\nexport let domLens = {\n  /**\n   * Takes a lens and returns a value/onChange pair that views/sets the lens appropriately. `onChange` sets with `e.target.value` (or `e` if that path isn't present).\n   *\n   * @signature lens -> {value, onChange}\n   * @example let Component = () => {\n   *   let state = React.useState('')\n   *   return <input {...F.domLens.value(state)}>\n   * }\n   */\n  value: targetBinding('value'),\n\n  /**\n   * Creates an includeLens and maps view to checked and set to `onChange` (set with `e.target.checked` or `e` if that path isn't present)\n   *\n   * @signature (value, lens) -> {checked, onChange}\n   */\n  checkboxValues: _.flow(includeLens, targetBinding('checked')),\n\n  /**\n   * Takes a lens and returns on onMouseEnter which calls `on` on the lens and onMouseLeave which calls `off`. Models a mapping of \"hovering\" to a boolean.\n   *\n   * @signature lens -> { onMouseEnter, onMouseLeave }\n   */\n  hover: (...lens) => ({\n    onMouseEnter: on(...lens),\n    onMouseLeave: off(...lens),\n  }),\n\n  /**\n   * Takes a lens and returns on onFocus which calls `on` on the lens and onBlur which calls `off`. Models a mapping of \"focusing\" to a boolean.\n   *\n   * @signature lens -> { onFocus, onBlur }\n   */\n  focus: (...lens) => ({\n    onFocus: on(...lens),\n    onBlur: off(...lens),\n  }),\n\n  /**\n   * Utility for building lens consumers like `value` and `checkboxValues`\n   *\n   * @signature field -> lens -> {[field], onChange}\n   */\n  targetBinding,\n\n  /**\n   * Even more generic utility than targetBinding which uses `getEventValue` to as the function for a setsWith which is mapped to `onChange`.\n   *\n   * @signature (field, getValue) -> lens -> {[field], onChange}\n   */\n  binding,\n}\n\n/**\n * Given the popularity of React, we decided to include this little helper that converts a `useState` hook call to a lens. Ex: `let lens = stateLens(useState(false))`. You generally won't use this directly since you can pass the `[value, setter]` pair directly to lens functions\n *\n * @signature ([value, setValue]) -> lens\n */\nexport let stateLens = ([value, set]) => ({ get: () => value, set })\n","import _ from 'lodash/fp'\nimport { push, mergeRanges } from './array'\nimport { insertAtIndex } from './collection'\n\n/**\n * Just like ramda test, creates a function to test a regex on a string.\n *\n * @signature regex -> string -> bool\n */\nexport const testRegex = _.curry((regex, str) => new RegExp(regex).test(str))\n\n/**\n * A curried implementation of `RegExp` construction.\n *\n * @signature options:string -> string -> regex\n */\nexport const makeRegex = (options) => (text) => RegExp(text, options)\n\n/**\n * Makes and tests a RegExp with makeRegex and testRegex.\n *\n * @signature options:string -> string -> (string -> bool)\n */\nexport const makeAndTest = (options) => _.flow(makeRegex(options), testRegex)\n\nexport const anyWordToRegexp = _.flow(_.words, _.join('|'))\n\nexport const wordsToRegexp = _.flow(\n  _.words,\n  _.map((x) => `(?=.*${x}.*)`),\n  _.join(''),\n  (x) => `.*${x}.*`\n)\n\nconst matchWords = _.curry((buildRegex, x) => {\n  // Not inlining so that we don't create the regexp every time\n  const regexp = RegExp(buildRegex(x), 'gi')\n  return (y) => !!(y && y.match(regexp))\n})\n\n/**\n * Returns true if the second string matches all of the words in the first string.\n *\n * @signature string -> string -> bool\n */\nexport const matchAllWords = matchWords(wordsToRegexp)\n\n/**\n * Returns true if the second string matches any of the words in the first string.\n *\n * @signature string -> string -> bool\n */\nexport const matchAnyWord = matchWords(anyWordToRegexp)\n\n/**\n * Returns an array of matches with start/end data\n *\n * @signature regex -> string -> [{text: string, start: number, end: number}]\n * @example F.allMatches(/a/g, 'vuhfaof') -> [ { text: 'a', start: 4, end: 5 } ]\n */\nexport const allMatches = _.curry((regexStr, str) => {\n  let matched\n  const regex = new RegExp(regexStr, 'g')\n  const result = []\n\n  while ((matched = regex.exec(str)) !== null) {\n    result.push({\n      text: matched[0],\n      start: matched.index,\n      end: regex.lastIndex,\n    })\n  }\n\n  return result\n})\n\n/**\n * Returns an array of postings (position ranges) for a regex and string to test, e.g. `F.postings(/a/g, 'vuhfaof') -> [[4, 5]]`\n *\n * @signature regex -> string -> [[number, number]]\n */\nexport const postings = _.curry((regex, str) => {\n  var match = regex.exec(str)\n  let result = []\n  if (regex.flags.indexOf('g') < 0 && match) {\n    result.push([match.index, match.index + match[0].length])\n  } else {\n    while (match) {\n      result.push([match.index, regex.lastIndex])\n      match = regex.exec(str)\n    }\n  }\n  return result\n})\n\n/**\n * Takes a string of words and a string to test, and returns an array of arrays of postings for each word.\n *\n * @signature words -> string -> [[[number, number]]]\n * @example F.postingsForWords('she lls', 'she sells sea shells')\n * // [\n * //   [[0, 3], [14, 17]]\n * //   [[6, 9], [17, 20]]\n * // ]\n */\nexport const postingsForWords = _.curry((string, str) =>\n  _.reduce(\n    (result, word) => push(postings(RegExp(word, 'gi'), str), result),\n    []\n  )(_.words(string))\n)\n\nexport const highlightFromPostings = _.curry((start, end, postings, str) => {\n  let offset = 0\n  _.each((posting) => {\n    str = insertAtIndex(posting[0] + offset, start, str)\n    offset += start.length\n    str = insertAtIndex(posting[1] + offset, end, str)\n    offset += end.length\n  }, mergeRanges(postings))\n  return str\n})\n\n/**\n * Wraps the matches for `pattern` found in `input` with the strings `start` and `end`. The `pattern` argument can either be a string of words to match, or a regular expression.\n *\n * @signature start -> end -> pattern -> input -> highlightedInput\n * @example let braceHighlight = F.highlight('{', '}')\n * braceHighlight('l o', 'hello world') //-> \"he{llo} w{o}r{l}d\"\n * braceHighlight(/l+\\w/, 'hello world') //-> \"he{llo} wor{ld}\"\n */\nexport const highlight = _.curry((start, end, pattern, input) =>\n  highlightFromPostings(\n    start,\n    end,\n    _.isRegExp(pattern)\n      ? postings(pattern, input)\n      : _.flatten(postingsForWords(pattern, input)),\n    input\n  )\n)\n","import _ from 'lodash/fp'\nimport { dotJoinWith, zipObjectDeepWith } from './array'\nimport { overNone, ifElse } from './logic'\nimport { isNotNil, isBlank } from './lang'\nimport {\n  reduceIndexed,\n  pickIn,\n  getIn,\n  hasIn,\n  mapIndexed,\n  mapValuesIndexed,\n  eachIndexed,\n  updateOn,\n  unsetOn,\n  setOn,\n} from './conversion'\nimport { findApply } from './collection'\nimport { aspects } from './aspect'\nimport { mapArgs } from './function'\nconst noCap = _.convert({ cap: false })\n\n/**\n * Creates an object with a key and value.\n *\n * @signature (k, v) -> {k: v}\n */\nexport const singleObject = _.curry((key, value) => ({ [key]: value }))\n\n/**\n * Flipped version of `singleObject`.\n *\n * @signature (v, k) -> {k: v}\n */\nexport const singleObjectR = _.flip(singleObject)\n\n/**\n * Breaks an object into an array of objects with one key each.\n *\n * @signature ({a, b}) -> [{a}, {b}]\n */\nexport const chunkObject = (value) =>\n  _.isArray(value) ? value : _.map(_.spread(singleObject), _.toPairs(value))\n\n/**\n * Remove properties with falsey values.\n *\n * @example ({ a: 1, b: null, c: false }) -> {a:1}\n */\nexport const compactObject = _.pickBy(_.identity)\n\n/**\n * Check if the variable is an empty object (`{}`).\n */\nexport const isEmptyObject = _.isEqual({})\n\n/**\n * Check if the variable is **not** an empty object (`{}`).\n */\nexport const isNotEmptyObject = _.negate(isEmptyObject)\n\n/**\n * Omit properties whose values are empty objects.\n *\n * @note (_TODO_ rename to `omitEmptyObjects`)\n * @example { a:1, b:{}, c:2 } -> {a:1, c:2}\n */\nexport const stripEmptyObjects = _.pickBy(isNotEmptyObject)\n\n// const crazyBS = (f, g) => (a, b) => f(a)(g(b))\n\n// { a: { b: 1, c: 2 } }, [ 'b' ] -> { a: { b: 1 } }\n\n/**\n * _TODO_\n */\nexport const pickInto = (map, source) => _.mapValues(pickIn(source), map)\n\n/**\n * Rename a property on an object.\n *\n * @signature sourcePropertyName -> targetPropertyName -> sourceObject -> sourceObject\n * @example renameProperty('a', 'b', { a: 1 }) -> { b: 1 }\n */\nexport const renameProperty = _.curry((from, to, target) =>\n  _.has(from, target)\n    ? _.flow((x) => _.set(to, _.get(from, x), x), _.unset(from))(target)\n    : target\n)\n\n/**\n *  Rename a property on an object.\n *  **NOTE**:Mutates the object\n *\n * @since 1.75.0\n * @signature sourcePropertyName -> targetPropertyName -> sourceObject -> sourceObject\n * @example renamePropertyOn('a', 'b', { a: 1 }) -> { b: 1 }\n */\nexport const renamePropertyOn = _.curry((from, to, target) => {\n  if (_.has(from, target))\n    _.flow((x) => setOn(to, _.get(from, x), x), unsetOn(from))(target)\n  return target\n})\n\n/**\n * Removes a property from an object and returns the removed value.\n * Like `F.unsetOn`, but returns the removed value instead of the mutated object. Similar to .pop() on arrays, but for objects.\n * Supports nested properties using dot notation.\n * NOTE: Mutates the object. If you don't want mutation, you probably want `_.unset` for the object or `_.get` for the value.\n * @since 1.75.0\n * @signature k -> { k: v } -> v\n */\nexport const popProperty = _.curry((prop, obj) => {\n  if (_.has(prop, obj)) {\n    let value = _.get(prop, obj)\n    unsetOn(prop, obj)\n    return value\n  }\n})\n\n/**\n * Just like mongo's `$unwind`: produces an array of objects from an object and one of its array-valued properties. Each object is constructed from the original object with the array value replaced by its elements. Unwinding on a nonexistent property or a property whose value is not an array returns an empty array.\n *\n * @signature k -> { k: [a, b] } -> [{ k: a }, { k: b }]\n * @example F.unwind('b', [{ a: true, b: [1, 2] }])\n * //=> [{ a: true, b: 1 }, { a: true, b: 2 }]\n */\nexport const unwind = _.curry((prop, x) =>\n  ifElse(\n    _.isArray,\n    _.map((y) => _.set(prop, y, x)),\n    _.stubArray,\n    _.get(prop, x)\n  )\n)\n\n/**\n * Unwinds an array of objects instead of a single object, as you might expect if you're used to mongo's `$unwind`. Alias for `(key, data) => _.flatMap(F.unwind(key), data)`\n *\n * @signature k -> [{ k: [a, b] }] -> [{ k: a }, { k: b }]\n * @example F.unwindArray('b', [\n *   { a: true, b: [1, 2] },\n *   { a: false, b: [3, 4] },\n * ])\n * //=> [\n * //=>  { a: true, b: 1 },\n * //=>  { a: true, b: 2 },\n * //=>  { a: false, b: 3 },\n * //=>  { a: false, b: 4 },\n * //=> ]\n */\nexport const unwindArray = _.curry((prop, xs) => _.flatMap(unwind(prop))(xs))\n\nexport const isFlatObject = overNone([_.isPlainObject, _.isArray])\n\n/**\n * Flatten an object with the paths for keys.\n *\n * @example { a: { b: { c: 1 } } } => { 'a.b.c' : 1 }\n */\nexport const flattenObject = (input, paths) =>\n  reduceIndexed(\n    (output, value, key) =>\n      _.merge(\n        output,\n        (isFlatObject(value) ? singleObjectR : flattenObject)(\n          value,\n          dotJoinWith(isNotNil)([paths, key])\n        )\n      ),\n    {},\n    input\n  )\n\n/**\n * Unlatten an object with the paths for keys.\n *\n * @example { 'a.b.c' : 1 } => { a: { b: { c: 1 } } }\n */\nexport const unflattenObject = (x) => _.zipObjectDeep(_.keys(x), _.values(x))\n\n/**\n * Returns true if object keys are only elements from signature list. (but does not require all signature keys to be present)\n */\nexport const matchesSignature = _.curry(\n  (signature, value) =>\n    _.isObject(value) && !_.difference(_.keys(value), signature).length\n)\n\n/**\n * Similar to `_.matches`, except it returns true if 1 or more object properties match instead of all of them. See https://github.com/lodash/lodash/issues/3713.\n */\nexport const matchesSome = _.flow(chunkObject, _.map(_.matches), _.overSome)\n\n/**\n * Checks if an object's property is equal to a value.\n */\nexport const compareDeep = _.curry(\n  (path, item, value) => _.get(path, item) === value\n)\n\n/**\n * _Deprecated in favor of lodash `update`_ Applies a map function at a specific path\n *\n * @example mapProp(double, 'a', {a: 2, b: 1}) -> {a: 4, b: 1}\n * @deprecated 1.46.0\n */\nexport const mapProp = aspects.deprecate(\n  'mapProp',\n  '1.46.0',\n  '_.update'\n)(noCap.update)\n\n/**\n * `_.get` that returns the target object if lookup fails\n */\nexport let getOrReturn = _.curry((prop, x) => _.getOr(x, prop, x))\n\n/**\n * `_.get` that returns the prop if lookup fails\n */\nexport let alias = _.curry((prop, x) => _.getOr(prop, prop, x))\n\n/**\n * Flipped `alias`\n */\nexport let aliasIn = _.curry((x, prop) => _.getOr(prop, prop, x))\n\n/**\n * A `_.get` that takes an array of paths (or functions to return values) and returns the value at the first path that matches. Similar to `_.overSome`, but returns the first result that matches instead of just truthy (and supports a default value)\n */\nexport let cascade = _.curryN(2, (paths, obj, defaultValue) =>\n  _.flow(\n    findApply((x) => x && _.iteratee(x)(obj)),\n    _.defaultTo(defaultValue)\n  )(paths)\n)\n\n/**\n * Flipped cascade\n */\nexport let cascadeIn = _.curryN(2, (obj, paths, defaultValue) =>\n  cascade(paths, obj, defaultValue)\n)\n\n/**\n * A `_.get` that takes an array of paths and returns the first path that matched\n */\nexport let cascadeKey = _.curry((paths, obj) => _.find(getIn(obj), paths))\n\n/**\n * A `_.get` that takes an array of paths and returns the first path that exists\n */\nexport let cascadePropKey = _.curry((paths, obj) => _.find(hasIn(obj), paths))\n\n/**\n * A `_.get` that takes an array of paths and returns the first value that has an existing path\n */\nexport let cascadeProp = _.curry((paths, obj) =>\n  _.get(cascadePropKey(paths, obj), obj)\n)\n\n/**\n * Opposite of `_.keyBy`. Creates an array from an object where the key is merged into the values keyed by `newKey`.\n *\n * @signature newKey -> {a:x, b:y} -> [{...x, newKey: a}, {...y, newKey: b}]\n * @note Passing a falsy value other than `undefined` for `newKay` will result in each object key being pushed into its corresponding return array member with itself as value, e.g. `F.unkeyBy('')({ a: { status: true}, b: { status: false }) -> [{ status: true, a: 'a' }, { status: false, b: 'b' }]`. Passing `undefined` will return another instance of F.unkeyBy.\n * @example F.unkeyBy('_key')({ a: { status: true}, b: { status: false }) -> [{ status: true, _key: 'a' }, { status: false, _key: 'b' }]\n */\nexport let unkeyBy = _.curry((keyName, obj) =>\n  mapIndexed((val, key) => _.extend(val, { [keyName || key]: key }))(obj)\n)\n\n/**\n * Produces a simple flattened (see `flattenObject`) diff between two objects. For each (flattened) key, it produced a `from` and a `to` value. Note that this will omit any values that are not present in the deltas object.\n *\n * @signature (from, to) -> simpleDiff\n */\nexport let simpleDiff = (original, deltas) => {\n  let o = flattenObject(original)\n  return _.flow(\n    flattenObject,\n    mapValuesIndexed((to, field) => ({ from: o[field], to })),\n    _.omitBy((x) => _.isEqual(x.from, x.to))\n  )(deltas)\n}\n\n/**\n * Same as `simpleDiff`, but produces an array of `{ field, from, to }` objects instead of `{ field: { from, to } }`\n *\n * @signature (from, to) -> [simpleDiffChanges]\n */\nexport let simpleDiffArray = _.flow(simpleDiff, unkeyBy('field'))\n\n/**\n * Same as `simpleDiff`, but also takes in count deleted properties.\n *\n * @signature (from, to) -> diff\n * @note We're considering not maintaining this in the long term, so you might probably have more success with any existing library for this purpose.\n */\nexport let diff = (original, deltas) => {\n  let o = flattenObject(original)\n  let d = flattenObject(deltas)\n  return _.flow(\n    mapValuesIndexed((_, field) => ({ from: o[field], to: d[field] })),\n    _.omitBy((x) => _.isEqual(x.from, x.to))\n  )(_.merge(o, d))\n}\n\n/**\n * Same as `simpleDiffArray`, but also takes in count deleted properties.\n *\n * @signature (from, to) -> [diffChanges]\n * @note We're considering not maintaining this in the long term, so you might probably have more success with any existing library for this purpose.\n */\nexport let diffArray = _.flow(diff, unkeyBy('field'))\n\n/**\n * A `_.pick` that mutates the object\n */\nexport let pickOn = (paths = [], obj = {}) =>\n  _.flow(\n    _.keys,\n    _.map((key) => {\n      if (!_.includes(key, paths)) {\n        delete obj[key]\n      }\n    })\n  )(obj)\n\nlet mergeArrays = (objValue, srcValue) =>\n  _.isArray(objValue) ? objValue.concat(srcValue) : undefined\n\n/**\n * Like `_.mergeAll`, but concats arrays instead of replacing. This is basically the example from the lodash `mergeAllWith` docs.\n */\nexport let mergeAllArrays = _.mergeAllWith(mergeArrays)\n\n/**\n * Similar to `_.invert`, but expands arrays instead of converting them to strings before making them keys.\n *\n * @signature { a: [x, y, z], b: [x] } -> { x: [a, b], y: [a], z: [a] }\n */\nexport let invertByArray = _.flow(\n  mapIndexed((arr, key) => zipObjectDeepWith(arr, () => [key])),\n  mergeAllArrays\n)\n\n/**\n * Iterates over object properties and stamps their keys on the values in the field name provided.\n *\n * @signature key -> { a: { x: 1 }, b: { y: 2 } } -> { a: { x: 1, key: 'a' }, b: { y: 2, key: 'b' } }\n */\nexport const stampKey = _.curry((key, x) =>\n  mapValuesIndexed((val, k) => ({ ...val, [key]: k }), x)\n)\n\n/**\n * `_.omitBy` using `_.isNil` as function argument.\n */\nexport let omitNil = (x) => _.omitBy(_.isNil, x)\n\n/**\n * `_.omitBy` using `_.isNull` as function argument.\n */\nexport let omitNull = (x) => _.omitBy(_.isNull, x)\n\n/**\n * `_.omitBy` using `F.isBlank` as function argument.\n */\nexport let omitBlank = (x) => _.omitBy(isBlank, x)\n\n/**\n * `_.omitBy` using `_.isEmpty` as function argument.\n */\nexport let omitEmpty = (x) => _.omitBy(_.isEmpty, x)\n\n/**\n * Composition of `_.over` and `_.mergeAll`. Takes an array of functions and an arbitrary number of arguments, calls each function with those arguments, and merges the results. Can be called with `mergeOverAll([f, g], x, y)` or `mergeOverAll([f, g])(x, y)`.\n *\n * @signature ([f, g], ...args) -> {...f(...args), ...g(...args)}\n * @note For functions that do not return objects, `_.merge`'s behavior is followed: for strings and arrays, the indices will be converted to keys and the result will be merged, and for all other primitives, nothing will be merged.\n */\nexport let mergeOverAll = _.curryN(2, (fns, ...x) =>\n  _.flow(_.over(fns), _.mergeAll)(...x)\n)\n\n/**\n * A customizable `mergeOverAll` that takes a function of the form `(objValue, srcValue) -> newValue` as its first argument; see [`_.mergeWith`](https://lodash.com/docs/latest#mergeWith). Both the customizer and array of functions can be partially applied.\n *\n * @signature (customizer, [f, g], ...args) -> {...f(...args), ...g(...args)}\n */\nexport let mergeOverAllWith = _.curryN(3, (customizer, fns, ...x) =>\n  _.flow(_.over(fns), _.mergeAllWith(customizer))(...x)\n)\n\n/**\n * A customized `mergeOverAll` that applies the array-merging behavior of `mergeAllArrays`.\n *\n * @signature ([f, g], ...args) -> {...f(...args), ...g(...args)}\n */\nexport let mergeOverAllArrays = mergeOverAllWith(mergeArrays)\n\n/**\n * Like `_.get`, but accepts a customizer function which is called on the value to transform it before it is returned. Argument order is `(customizer, path, object)`.\n *\n * @signature (x -> y) -> k -> {k: x} -> y\n */\nexport let getWith = _.curry((customizer, path, object) =>\n  customizer(_.get(path, object))\n)\n\n/**\n * Accepts a transform function and an object. Returns the result of applying the transform function to the object, merged onto the original object. `expandObject(f, obj)` is equivalent to `mergeOverAll([_.identity, f], obj)`.\n *\n * @signature (transform: obj -> newObj) -> obj -> { ...obj, ...newObj }\n */\nexport let expandObject = _.curry((transform, obj) => ({\n  ...obj,\n  ...transform(obj),\n}))\n\n/**\n * Expands an object by transforming the value at a single key into a new object, and merging the result with the original object. Similar to `expandObject`, but the argument order is `(key, transform, object)`, and the transform function is called on the value at that key instead of on the whole object.\n *\n * @signature key -> (transform: x -> newObj) -> (obj: { key: x }) -> { ...obj, ...newObj }\n */\nexport let expandObjectBy = _.curry((key, fn, obj) =>\n  expandObject(getWith(fn, key))(obj)\n)\n\n/**\n * Takes two objects and returns the keys they have in common\n *\n * @signature (x, y) -> [keys]\n */\nexport let commonKeys = _.curryN(2, mapArgs(_.keys, _.intersection))\nlet findKeyIndexed = _.findKey.convert({ cap: false })\n\n/**\n * Takes two objects and returns the first key in `y` that x also has\n *\n * @signature (x, y) -> key\n */\nexport let firstCommonKey = _.curry((x, y) =>\n  findKeyIndexed((val, key) => _.has(key, x), y)\n)\n\n/**\n * Like `_.update`, but does not call the iteratee if the path is missing on the object\n * @signature (path, updater, object) -> object\n * @since 1.75.0\n */\nexport let updateIfExists = _.curry((path, updater, object) =>\n  _.has(path, object) ? _.update(path, updater, object) : object\n)\n\n/**\n * Like `F.updateOn`, but does not call the iteratee if the path is missing on the object\n * *Mutates* the object\n * @signature (path, updater, object) -> object\n * @since 1.75.0\n */\nexport let updateIfExistsOn = _.curry((path, updater, object) =>\n  _.has(path, object) ? updateOn(path, updater, object) : object\n)\n\nlet _updateMany = _.curry((updater, transforms, data) =>\n  _.flow(\n    flattenObject,\n    eachIndexed((transform, path) =>\n      updater(path, _.iteratee(transform), data)\n    ),\n    () => data // return mutated data\n  )(transforms)\n)\n\n/**\n * Similar to ramda's `R.evolve`, but supports lodash iteratees and nested paths.\n * Applies transforms to the target object at each path. The transform function is called with the value at that path, and the result is set at that path.\n * Transforms are **not** called for paths that do not exist in the target object.\n * Transform functions support lodash iteratee shorthand syntax.\n * Deep paths are supported by nesting objects and by dotted the keys\n *\n * Note: *Mutates* the target object for performance. If you don't want this, use `updatePaths` or clone first.\n *\n * @signature ({ path: transform }, target) -> obj\n * @since 1.75.0\n */\nexport let updatePathsOn = _updateMany(updateIfExistsOn)\n\n/**\n * Similar to ramda's `R.evolve`, but supports lodash iteratees and nested paths.\n * Applies transforms to the target object at each path. The transform function is called with the value at that path, and the result is set at that path.\n * Transforms **are** called for paths that do not exist in the target object.\n * Transform functions support lodash iteratee shorthand syntax.\n * Deep paths are supported by nesting objects and by dotted the keys\n *\n * Note: *Mutates* the target object for performance. If you don't want this, use `updateAllPaths` or clone first.\n *\n * @signature ({ path: transform }, target) -> obj\n * @since 1.75.0\n */\nexport let updateAllPathsOn = _updateMany(updateOn)\n\n/**\n * Similar to ramda's `R.evolve`, but supports lodash iteratees and nested paths.\n * Applies transforms to the target object at each path. The transform function is called with the value at that path, and the result is set at that path.\n * Transforms **are** called for paths that do not exist in the target object.\n * Transform functions support lodash iteratee shorthand syntax.\n * Deep paths are supported by nesting objects and by dotted the keys\n *\n * *Note* Deep clones prior to executing to avoid mutating the target object, but mutates under the hood for performance (while keeping it immutable at the surface). If you're doing this in a place where mutating is safe, you might want `F.updateAllPathsOn` to avoid the `_.deepClone`\n *\n * @signature ({ path: transform }, target) -> obj\n * @since 1.75.0\n */\nexport let updateAllPaths = _.curry((transforms, data) =>\n  updateAllPathsOn(transforms, _.cloneDeep(data))\n)\n\n/**\n * Similar to ramda's `R.evolve`, but supports lodash iteratees and nested paths.\n * Applies transforms to the target object at each path. The transform function is called with the value at that path, and the result is set at that path.\n * Transforms are **not** called for paths that do not exist in the target object.\n * Transform functions support lodash iteratee shorthand syntax.\n * Deep paths are supported by nesting objects and by dotted the keys\n *\n * *Note* Deep clones prior to executing to avoid mutating the target object, but mutates under the hood for performance (while keeping it immutable at the surface). If you're doing this in a place where mutating is safe, you might want `F.updatePathsOn` to avoid the `_.deepClone`\n *\n * @signature ({ path: transform }, target) -> obj\n * @since 1.75.0\n */\nexport let updatePaths = _.curry((transforms, data) =>\n  updatePathsOn(transforms, _.cloneDeep(data))\n)\n\n/**\n * Calls a function or defaults to isEqual, used internally by _matchesBy\n *\n * @private\n * @typescript (fn: (x: any) => any | any, value: any)\n */\nlet callOrCompare = (fn, value) =>\n  _.isFunction(fn) ? fn(value) : _.isEqual(fn, value)\n\n/**\n * Internal function used by `matchesBy` and `matchesBySome`\n *\n * @private\n * @typescript (combiner: (values: boolean[]) => boolean, criteria: object, object: object)\n */\nlet _matchesBy = _.curry((combiner, criteria, object) =>\n  _.flow(\n    mapValuesIndexed((value, key) => callOrCompare(value, _.get(key, object))),\n    _.values,\n    combiner\n  )(criteria)\n)\n\n/**\n * Takes a criteria object and an object to test against it, and returns true if all the values in the criteria match the values in the object\n * Criteria values can be functions or values to compare against\n * Supports dot notation for deep paths\n *\n * @signature (criteria: object, object: object) -> boolean\n */\nexport let matchesBy = _matchesBy(_.every((x) => x))\n\n/**\n * Takes a criteria object and an object to test against it, and returns true if some of the values in the criteria match the values in the object\n * Criteria values can be functions or values to compare against\n * Supports dot notation for deep paths\n *\n * @signature (criteria: object, object: object) -> boolean\n */\nexport let matchesBySome = _matchesBy(_.some((x) => x))\n","import { map } from './collection'\nimport _ from 'lodash/fp'\nimport { when } from './logic'\nimport { intersperse } from './array'\nimport { differentLast } from './iterators'\nimport { isBlank } from './lang'\n\nlet blankString = when(isBlank, '')\n/**\n * Wraps a string with pre and post unless content is nil (and replaces )\n * @signature (pre, post, content) -> pre + content + post\n * @param {string} pre\n * @param {string} post\n * @param {string} content\n * @returns string\n */\nexport const wrap = _.curry((pre, post, content) =>\n  isBlank(content)\n    ? blankString(content)\n    : blankString(pre) + content + blankString(post)\n)\nexport const quote = wrap('\"', '\"')\n\n/**\n * Wraps a string in parenthesis.\n *\n * @signature 'asdf' -> '(asdf)'\n */\nexport const parens = wrap('(', ')')\nexport const concatStrings = _.flow(_.compact, _.map(_.trim), _.join(' '))\n\n/**\n * Maps `_.trim` through all the strings of a given object or array.\n *\n */\nexport const trimStrings = map(when(_.isString, _.trim))\n\n// _.startCase does the trick, deprecate it!\n/**\n * Converts strings like variable names to labels (generally) suitable for GUIs, including support for acronyms and numbers. It's basically `_.startCase` with acronym and number support.\n *\n * @signature string -> string\n */\nexport let autoLabel = _.startCase\n\n/**\n * Creates a `{value, label}` which applies `autoLabel` the string parameter on puts it on the label property, with the original on the value property. You can also pass in an object with value or with both value and label.\n *\n * @signature string -> {value:string, label:string}\n */\nexport let autoLabelOption = (a) => ({\n  value: when(_.isUndefined, a)(a.value),\n  label: a.label || autoLabel(when(_.isUndefined, a)(a.value)),\n})\n\n/**\n * Applies `autoLabelOption` to a collection. Useful for working with option lists like generating select tag options from an array of strings.\n *\n * @signature [string] -> [{value:string, label:string}]\n */\nexport let autoLabelOptions = _.map(autoLabelOption)\n\n/**\n * Just like `toSentence`, but with the ability to override the `separator` and `lastSeparator`\n *\n * @signature (separator, lastSeparator, array) => string\n * @example (' - ', ' or ', ['a', 'b', 'c']) -> 'a - b or c'\n */\nexport let toSentenceWith = _.curry((separator, lastSeparator, array) =>\n  _.flow(\n    when(_.isString, (x) => [x]),\n    intersperse(\n      differentLast(\n        () => separator,\n        () => lastSeparator\n      )\n    ),\n    _.join('')\n  )(array)\n)\n\n/**\n * Joins an array into a human readable string. See https://github.com/epeli/underscore.string#tosentencearray-delimiter-lastdelimiter--string\n *\n * @signature array => string\n * @example ['a', 'b', 'c'] -> 'a, b and c'\n */\nexport let toSentence = toSentenceWith(', ', ' and ')\n\n/**\n * Allows passing a \"cachizer\" function (`array -> object`) to override the way `uniqueString`'s initial array is converted into a cache object. Can be curried to create a custom `uniqueString` function, eg: `let myUniqueString = uniqueStringWith(myFunc)`\n\nLike `uniqueString`, the resulting deduplication function exposes `cache` and `clear()` properties.\n * \n * @signature (fn, array) -> string -> string\n * @example let uniqueStringStripDigits = uniqueStringWith(\n *   _.countBy(_.replace(/(\\d+)$/, ''))\n * )\n * let dedupe = uniqueStringStripDigits(['foo', 'foo42', 'foo3000'])\n * dedupe('foo') //-> 'foo3'\n * uniqueStringWith(_.identity, dedupe.cache)('foo') //-> 'foo4'\n */\nexport let uniqueStringWith = _.curry((cachizer, initialKeys) => {\n  let f = (x) => {\n    let result = x\n    while (cache[result]) {\n      result = x + cache[x]\n      cache[x] += 1\n    }\n    cache[result] = (cache[result] || 0) + 1\n    return result\n  }\n  let cache = cachizer(initialKeys)\n  f.cache = cache\n  f.clear = () => {\n    cache = {}\n    f.cache = cache\n  }\n  return f\n})\n\n/**\n * Returns a function that takes a string and de-duplicates it against an internal cache. Each time this function is called, the resulting deduplicated string is added to the cache. Exposes `cache` and `clear()` properties to read and clear the cache, respectively.\n *\n * @signature array -> string -> string\n * @example let dedupe = uniqueString()\n * _.map(dedupe, ['foo', 'foo', 'foo']) //-> ['foo', 'foo1', 'foo2']\n * dedupe.cache //-> { foo: 3, foo1: 1, foo2: 1 }\n * dedupe.clear()\n * dedupe.cache //-> {}\n * dedupe('foo') //-> 'foo'\n */\nexport let uniqueString = (arr = []) =>\n  uniqueStringWith(_.countBy(_.identity), arr)\n\n/**\n * Replaces whitespace substrings with a single space and trims leading/trailing whitespace\n *\n * @signature string -> string\n * @typescript <T>(x: T): string | T\n * @since 1.75.0\n */\nexport let crunchWhitespace = (x) =>\n  _.isString(x) ? _.trim(_.replace(/\\s+/g, ' ', x)) : x\n","import _ from 'lodash/fp'\nimport { resolveOnTree } from './tree'\n\n/**\n * Like `Promise.all`, but for objects. Polyfill bluebird Promise.props. Takes an object with promise values and returns a promise that resolves with an object with resolved values instead.\n *\n * @signature { a: Promise, b: Promise} => Promise<{a: value, b: value}>\n */\nexport let promiseProps =\n  Promise.props ||\n  ((x) =>\n    Promise.all(_.values(x)).then((values) => _.zipObject(_.keys(x), values)))\n// async/await still causes regeneratorRuntime issues downstream :(\n// (async (x) => _.zipObject(_.keys(x), await Promise.all(_.values(x))))\n\n// Calls then conditionally, allowing flow to be used synchronously, too\nlet asyncCall = (value, f) => (value.then ? value.then(f) : f(value))\nlet asyncCallShallow = (prop, f) => {\n  if (_.some('then', prop)) {\n    if (_.isArray(prop)) return Promise.all(prop).then(f)\n    if (_.isPlainObject(prop)) return promiseProps(prop).then(f)\n  }\n  return asyncCall(prop, f)\n}\nlet asyncCallDeep = (prop, f) => {\n  prop = resolveOnTree()(prop)\n  return asyncCall(prop, f)\n}\n// This implementation of `flow` spreads args to the first method and takes a method to determine how to combine function calls\nlet flowWith =\n  (call) =>\n  (fn0, ...fns) =>\n  (...x) =>\n    [...fns, (x) => x].reduce(call, fn0(...x))\n\n/**\n * Like `_.flow`, but supports flowing together async and non async methods.\n * If nothing is async, it *stays synchronous*.\n * Also, it handles awaiting arrays of promises (e.g. from _.map) with `Promise.all` and objects of promises (e.g. from _.mapValues) with `promiseProps`.\n * This method generally solves most issues with using futil/lodash methods asynchronously. It's like magic!\n * NOTE: Main gotchas are methods that require early exit like `find` which can't be automatically async-ified. Also does not handle promises for keys.\n * Use `F.resolveOnTree` to await more complexly nested promises.\n *\n * @signature (f1, f2, ...fn) -> (...args) => fn(f2(f1(...args)))\n */\nexport let flowAsync = flowWith(asyncCallShallow)\n\n/**\n * Just like `F.flowAsync`, except it recurses through return values using `F.resolveOnTree` instead of just `Promise.all` or `promise.props`\n * _CAUTION_ Just like `resolveOnTree`, this will mutate intermediate results to resolve promises. This is generally safe (and more performant) but might not always be what you expect.\n *\n * @signature (f1, f2, ...fn) -> (...args) => fn(f2(f1(...args)))\n */\nexport let flowAsyncDeep = flowWith(asyncCallDeep)\n","import _ from 'lodash/fp'\n\nexport * from './async'\nexport * from './conversion'\nexport * from './collection'\nexport * from './function'\nexport * from './string'\nexport * from './object'\nexport * from './aspect'\nexport * from './array'\nexport * from './logic'\nexport * from './regex'\nexport * from './lang'\nexport * from './lens'\nexport * from './tree'\nexport * from './iterators'\n\nimport * as async from './async'\nimport * as conversion from './conversion'\nimport * as collection from './collection'\nimport * as fn from './function'\nimport * as string from './string'\nimport * as object from './object'\nimport * as aspect from './aspect'\nimport * as array from './array'\nimport * as logic from './logic'\nimport * as regex from './regex'\nimport * as lang from './lang'\nimport * as lens from './lens'\nimport * as tree from './tree'\nimport * as iterators from './iterators'\n\n// Math\n// ----\n\n/**\n * Returns true if number is greater than one.\n *\n * @signature number -> bool\n * @tags math\n */\nexport const greaterThanOne = _.lt(1)\n\n// Promise\n// ----\n\n/**\n * A utility that checks if the argument passed in is of type promise\n *\n * @signature x -> bool\n * @tags lang\n */\nexport const isPromise = (obj) =>\n  !!obj &&\n  (typeof obj === 'object' || typeof obj === 'function') &&\n  typeof obj.then === 'function'\n\n// Version\n// ----\n// eslint-disable-next-line\nexport const VERSION = global.__VERSION__\n\n// Allows `import F from 'futil-js'`\nexport default {\n  ...async,\n  ...conversion,\n  ...collection,\n  ...fn,\n  ...string,\n  ...object,\n  ...aspect,\n  ...array,\n  ...logic,\n  ...regex,\n  ...lang,\n  ...lens,\n  ...tree,\n  ...iterators,\n  greaterThanOne,\n  isPromise,\n  VERSION,\n}\n"],"sourceRoot":""}